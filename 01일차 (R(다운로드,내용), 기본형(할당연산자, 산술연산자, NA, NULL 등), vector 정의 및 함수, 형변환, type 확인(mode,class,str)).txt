# R

뉴질랜드 aukland 대학 Ross lhaka, Robert clifford gentleman
1995년에 개발한 소프트웨어이고 데이터 분석을 위한 통계 및 그래픽스를 지원하는 무료소프트웨어이다.

# R을 사용해야하는 이유

1. R은 free 이다.
2. 데이터 분석을 위해서 가장 많이 쓰는 통계 플랫폼이다.
3. 복잡한 데이터를 다향한 그래프로 표현할 수 있다.
4. 분석을 위한 데이터를 쉽게 저장하고 조작할 수 있다.
5. 누구든지 유용한 패키지를 생성해서 공유할 수 있고 새로운 기능에 대한 전달이 빠르다. - R developer
6. 어떠한 OS에서 설치가 가능하다.

# 통계 플랫폼을 가지고 다른 사이트에게 지불을 해달라고 하면 R에도 라이센스 값이 발생한다.

# R 설치

http://www.r-project.org/
http://www.rstudio.com/ -- TOOL

# 변수 

- 변수이름은 알파벳, 숫자, _, .(마침표) 사용한다.
- 변수이름의 첫 글자는 알파벳, .(마침표) 로 시작할 수 있다.
- .(마침표)로 시작할 경우에는 바로 뒤에 숫자를 입력할 수 없다. 

예) 변수 이름으로 가능
	a, i, x2, .y
    변수 이름으로 불가능
	1a, .2, k-j

# 변수에 값 할당연산자(<-, <<-, =)

x <- 1 (할당연산자, 대입연산자), 이 연산자를 사용하는 것이 가장 좋다.
x - 출력방법 1
print(x) - 출력방법 2

y<<-2
y
print(y)

# 자동으로 값의 따라 타입이 적용이 된다.

z = 3
z
print(z)

x+y+z

sum(x<-c(1,2,3,4,5)) - c: 1차원배열 생성하는 함수, sum: 배열 안에 있는 값을 더하는 함수
[1] 15
x -- 1차원 배열을 확인 할 수 있다.
[1] 1 2 3 4 5

# 항상 R과 PL/SQL 다른 언어랑 비교를 하면서 해야 도움이 된다.

이미 x라는 변수를 선언했었지만 밑에서 다시 선언함으로써 기존값은 없어지고 마지막에 선언한 값이 남는다.

> sum(y=c(1,2,3,4,5))
[1] 15
> y
[1] 2 -> 2로 나오게 된다. 즉, 전역변수/지역변수로 나누게 되는 것이다.

sum(d=c(1,2,3,4,5))
[1] 15
d -> 위에서 선언하였지만 그 부분에서만 적용이 되는 것이다. 즉, 지역변수의 정의와 같다.
에러: 객체 'd'를 찾을 수 없습니다

<- : 전역변수 : 값은 선언함과 동시에 다른값으로 바뀌게 된다.
= : 지역변수 : 값을 선언하면 그 선언했을 때의 값만 유지가 되고 다음엔 유지가 되지 않는다.

# 숫자(정수, 실수)

x<-2
print(x)
class(x) 
[1] "numeric" -- class : 변수의 type을 return 해주는 함수 (numeric: 실수) , R은 보편적으로 실수로 표현을 한다.

y<-2L -- 반드시 대문자로 적어야한다. R은 대소문자를 구분하기 때문에 주의해야한다.
print(y)
[1] 2
class(y) 
[1] "integer" -- L을 이용하면 정수로 표현이 된다.

z<-x+y
print(z)
[1] 4
class(z)
[1] "numeric" -- 정수+실수를 더하게 되면 실수로 나오게 된다.

str(z) -- str: class와 비슷한 기능으로 타입을 확인할 수 있는 기능이다.
num 4 

is.numeric(z) -- is: True/False (boolean 형식으로 나오는 함수) is.타입
[1] TRUE

is.integer(y)
[1] TRUE

is.integer(x) - 실수형으로 변수타입이 되어있기 때문에 값은 정수더라도 변수타입에 따라 True/False가 나온다.
[1] FALSE

# 문자열 : '', "" 모두 상관이 없다.

s1 <- 'hello'
s1 
[1] "hello"
class(s1)
[1] "character"
s2 <- "안녕하세요"
s2
[1] "안녕하세요"
class(s2)
[1] "character"

is.character(s2) -- char인지 아닌지 판단.

# boolean(진리값) : True/False , AND : &, OR : |

> TRUE & TRUE
[1] TRUE
> TRUE & FALSE
[1] FALSE
> FALSE & TRUE
[1] FALSE
> FALSE & FALSE
[1] FALSE

> TRUE | TRUE 
[1] TRUE
> TRUE | FALSE
[1] TRUE
> FALSE | FALSE
[1] FALSE

T & T -- 이렇게도 가능하지만 전체 적어주는 것이 좋다. (항상 대문자 사용★)
T & F
T | T
T | F

T <- TRUE
T
F <- FALSE
F

class(T)
[1] "logical"
> is.logical(T) -- is.logical: class와 비슷하다.
[1] TRUE
> is.logical(F)
[1] TRUE
> is.logical(z)
[1] FALSE

# NA(Not Available) : 결측(치)값, 데이터 입력 중 실수로 값이 입력 되지 않는 경우

a<-100; b<-90; c<-NA; -- 한줄로 넣는 방법 : ; 사용 

[1] 100
> b
[1] 90
> c
[1] NA
> a+b+c - 결측지가 있어 NA이다. 
[1] NA
> is.na(c)
[1] TRUE
> is.na(a)
[1] FALSE

★ NULL : 변수에 초기화되지 않을 때 사용, undefined값을 표현, 대문자사용

x<-NULL
 is.null(x) - null 인지 판단, 소문자로 사용
> is.na(x)
logical(0) - null 과 na는 다르다.
y<-100
x+y
numeric(0) -- 의미 : 하나의 값은 NULL 인 것을 의미한다.

z<-NA
z+y
[1] NA -- 하나의 값은 NA인 것을 확인할 수 있다. (NA는 우리가 아는 NULL과 같은것이다.)

# 변수에 타입을 쓰지않기 때문에 어떤값이라도 넣어 놓으려면 즉, 다른값이 어떤값이 뭐가 들어올지 모른다면 NULL로 해놓는다. (초기값이 뭐가 들어올지 모를때)

# NA는 정말 값을 모르겠다라는 의미이다.

# 산술연산자
> 1+2
[1] 3
> 100-99
[1] 1
> 99-100
[1] -1
> 1+2
[1] 3
> 100-99
[1] 1
> 99-100
[1] -1
> 2*3
[1] 6
> 100/2
[1] 50
> 100/3 -- 일반 나누기
[1] 33.33333
> 100%/%3 -- 몫 값만 구하는 방법
[1] 33
> 100%%3 -- 나머지 값만 구하는 방법, pl/sql mod와 같다.
[1] 1
> 10^2 -- 거듭제곱을 의미한다. PL/SQL-POWER power(10,2)

[1] 100
> 10**2 -- 거듭제곱 같은 의미.

[1] 100

# 비교연산자: >,<,<=,>=, ==, !=

10>5
10<5
10>=5
10<=5
10==5
10!=5> 
10>9 & 10>=10 -- 가능하다.
[1] TRUE
10>9 | 10>=10
[1] TRUE

# 지수 형식 (지수 표기법), 숫자

1e2 : 1 * 10^2
[1] 100
5e-1
> 5e-1 : 5 * 10^(-1)
[1] 0.5
> 5e-2 : 5 * 10^(-2)
[1] 0.05
[1] 0.05
> 100000 -- 어느정도 크기가 커지면 지수표기법으로 표기한다.
[1] 1e+05
> 1e+05
[1] 1e+05

★★ 자료형

1. vector(벡터)

 - 같은 데이터 타입을 갖는 1차원 배열구조 (R의 기본데이터 구조)
 - c() : combine value
 - 벡터는 중첩이 불가능 하다.
 - 벡터는 단일 데이터 타입만 가능하다.
 - 데이터 변환규칙 : integer < double(실수가 생각하면 된다.) < character

x <- c(1,2,3,4,5)
x
[1] 1 2 3 4 5

> mode(x)
[1] "numeric"
> class(x)
[1] "numeric"
> str(x)
 num [1:5] 1 2 3 4 5

# 벡터는 단일값(단일type으로만 가능)으로만 가능하기 때문에 수보다 규칙이 더 큰 character로 바뀌게 된다.

> x <- c(1,2,3,4,'5')
> x
[1] "1" "2" "3" "4" "5"
> mode(x) 
[1] "character"
> class(x)
[1] "character"
> str(x)
 chr [1:5] "1" "2" "3" "4" "5"

# integer < double(numeric)

> x <- c(1,2,3.14,4,5)
> x
[1] 1.00 2.00 3.14 4.00 5.00
> mode(x)
[1] "numeric"
> class(x) 
[1] "numeric"
> str(x)
 num [1:5] 1 2 3.14 4 5

# 중첩은 불가능 하다.

> x<-c(1,2,3,c(4,5))
> x
[1] 1 2 3 4 5

> s1<-c('서울','대구','광주','부산')
> mode(s1)
[1] "character"
> class(s1)
[1] "character"
> str(s1)
 chr [1:4] "서울" "대구" "광주" "부산" -- 범위도 알려준다. [1:4] -> 1번방부터 4번방까지 chracter임을 보여준다.

x<-c(1,2,3,sum=c(4,5)) -- 컬럼 이름처럼 사용된다. (변수처리)
y<-c(1,2,3,sum(c(4,5))) -- 더한값으로 나오게 된다.

> x
               sum1 sum2 
   1    2    3    4    5
> sum
[1] 4 5 

> y
[1] 1 2 3 9

> x<-c(1,2,3,sum<-c(4,5)) -- 이건 아무것도 되지 않는다. 이유: 중첩과 같은 부분으로 읽기 때문에 1 2 3 4 5 로 나오게 된다.
> x
[1] 1 2 3 4 5
> sum
[1] 4 5

> x<-c("국어"=90,"수학"=95,"영어"=80) -- 각각 과목들의 이름은 셀 이름이 된다.
> x
국어 수학 영어 
  90   95   80 

> z<-c("과목"=c(80,90,96)) - 자동으로 numbering 발생을 한다.
> z
과목1 과목2 과목3 
   80    90    96 

> z<-c(과목=c(80,90,96))
> z
과목1 과목2 과목3 
   80    90    96
 

> names(z)<-c("국어","영어","수학") -- names : 컬럼이름 추가하는 함수
> z
국어 영어 수학 
  80   90   96 

# 셀 각각의 이름을 지우고 싶다면 NULL로 해야한다.

> names(z)<-NULL 
> z
[1] 80 90 96

> names(z)<-NA -- NA로 할 경우 각각 이름에 NA로 명칭이 된다.
> z
<NA> <NA> <NA> 
  80   90   96 

> y<-c(1,2,3,4,5)
> y
[1] 1 2 3 4 5
> names(y)<-c('하나','둘','셋','넷','다섯')
> y

하나   둘   셋   넷 다섯 
   1    2    3    4    5 


# names: 벡터의 각 셀에 이름을 설정
# length(y) : 벡터의 길이
# NROW(y) : 같다. 벡터의 길이를 나타낸다. <대문자> (pl/sql count와 같다.)

# 배열은 항상 1번부터 시작한다,
# 벡터의 요소번호를 이용하는 방법: 대괄호를 통해서 위치를 나타낼수 있다
예) y[1]
    y[2]
    y[1:3] 
    y[c(-1,-3)] -- 선택한것을 제외하고 실행한다.
  둘   넷 다섯 
   2    4    5 
    y[c(-1)]
  둘   셋   넷 다섯 
   2    3    4    5

# 셀 이름으로도 값을 찾을 수 있다 

>  y["하나"] 
하나 
   1

> y[c("하나","다섯")] 
하나 다섯 
   1    5 

> y[-1:-4]
다섯 
   5 

# 연속되는 값을 표현하는 방법

x<-1:100
 x
  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33
 [34]  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66
 [67]  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99
[100] 100

x<-c(1:1000) -- c(시작값:종료값) : 시퀀스한값 표현
#  sequence : 자동일련번호를 생성,  seq(시작값,종료값,증가분)
x<-seq(1,5,1)
y<-seq(0,1000,5)

10:1 -- 리버스가 된다.

seq(10,0,-1)
 [1] 10  9  8  7  6  5  4  3  2  1  0

x<-c(2,4,6,8,10)
# seq_along(x) -- x변수의 길이만큼 인덱스에 값을 넣어서 표현하겠다는 것을 의미한다. (개수만큼 표현하고 싶을때 사용한다.)
[1] 1 2 3 4 5

1:NROW(x) - 응용

# 반복되는 값 표현 - rep

rep(1:5,times=2)  - 전체값을 2번 표현

 [1] 1 2 3 4 5 1 2 3 4 5

rep(1:5, each=2) - 각각의 값을 2번씩 표현
 [1] 1 1 2 2 3 3 4 4 5 5


rep(1:5,each=2,times=2)
 [1] 1 1 2 2 3 3 4 4 5 5 1 1 2 2 3 3 4 4 5 5

# 벡터의 값 수정

x<-c(1:5)
x[2] <- 8 :  2번째의 요소값을 8로 수정
> x
[1] 1 8 3 4 5

> x[3:5]<-c(30,40,50) : 3~5번째 값 수정
> x
[1]  1  8 30 40 50

# 벡터의 값을 추가하는 방법

> x[6]<-60
> x
[1]  1  8 30 40 50 60

> x[8]<-80 -- 7번방은 값이 없고 8번에 넣어야 하기 때문에 NA로 추가된다. <결측지 추가>
> x
[1]  1  8 30 40 50 60 NA 80

> x[7] <- 70 -- 7번방 값이 추가가 된다.
> x
[1]  1  8 30 40 50 60 70 80

# append(x,90,after=8) append(변수이름,값,after=요소번호) : 값만 적용해줄뿐 저장이 되지 않는다. / 정확한 변수에 값을 넣지 않았기 때문에 

 append(x,90,after=8)
[1]  1  8 30 40 50 60 70 80 90

> x
[1]  1  8 30 40 50 60 70 80

# x에 추가하려면 직접 변수 값에 x를 적어야한다

x<-append(x,90,after=8)
> x<-append(x,90,after=8) -- 추가 확인
> x
[1]  1  8 30 40 50 60 70 80 90

> x<-append(x,6,after=6) -- 방과 방사이 값 추가하는 방법
> x
 [1]  1  8 30 40 50 60  6 70 80 90

# 벡터연산

> x<-c(1:5) 
> x+10 -- 각각의 배열 값에 10씩 더한다는 의미 / 적용은 되지않는다. 변수지정을 하지 않았기 때문에.
[1] 11 12 13 14 15

> x*10
[1] 10 20 30 40 50
> x/2
[1] 0.5 1.0 1.5 2.0 2.5
> x%%2
[1] 1 0 1 0 1
> x%/%2
[1] 0 1 1 2 2

# 벡터 변수끼리 비교하기 / 배열비교 

x<-c(1,2,3)
y<-c(1,2,3)
z<-c(1,2,4)

> x==y
[1] TRUE TRUE TRUE
> y==z
[1]  TRUE  TRUE FALSE

# identical - 배열을 하나로 보고 비교하기

> identical(x,y)
[1] TRUE
> identical(x,z)
[1] FALSE


# 요소의 갯수가 맞지 않을경우 값은 뜨지만 오류메세지 값이 나온다.

w<-c(1:5)
> x==w
[1]  TRUE  TRUE  TRUE FALSE FALSE
경고메시지(들): 
In x == w : 두 객체의 길이가 서로 배수관계에 있지 않습니다

# 하지만 identical 을 사용할 경우 FALSE로 나오게 된다.
> identical(x,w)
[1] FALSE

x <- c(1,2,3,4)
y <- c(1,2,3,4,4)

> x==y
[1]  TRUE  TRUE  TRUE  TRUE FALSE
경고메시지(들): 
In x == y : 두 객체의 길이가 서로 배수관계에 있지 않습니다

> identical(x,y) : 두벡터의 값이 동일한지 판단. (값과 배열의 길이 비교)
[1] FALSE

> setequal(x,y) : 두벡터의 같은 집합인지 판단 <중복되는 값이 있으면 같은집합으로 본다.> 1234 1234 이렇게 비교 (값으로 비교)
[1] TRUE

x<-c(1,2,3,4)
y<-c(1,4,6)

> union(x,y) : 합집합을 의미
[1] 1 2 3 4 6

> intersect(x,y) : 교집합을 의미
[1] 1 4

> setdiff(x,y) : 차집합을 의미한다.
[1] 2 3

> 1 %in% x : 값이 있는지 없는지 판단할 수 있다. (숫자 %in% 변수)
[1] TRUE

 > 5 %in% x
[1] FALSE

x<-c('b','a','d','a',NA)
x

> 'a' %in%x
[1] TRUE

> x=='a'
[1] FALSE  TRUE FALSE TRUE NA

> x[x=='a'] -- a가 몇개 있는지 알 수 있다. 하지만 NA가 있다면 NA가 나온다.
[1] "a" "a" NA 

# 어느 위치에 있는지 확인하는 방법 - which
-- 조건에 해당하는 요소번호 찾기
> which('a'==x)
[1] 2 4

응용

>x[which('a'==x)] -- 요소번호로 값찾는거와 같다.
[1] "a" "a"

> is.na(x)
[1] FALSE FALSE FALSE FALSE  TRUE
> which(NA==x) -- 값이 나오지 않는다.
integer(0)
> which(is.na(x)) -- null 을 찾는것 처럼 is.na를 통해서 위치를 찾는다.
[1] 5

# 값 수정방법

x[which('a'==x)] <- 'aa'

# 값의 타입을 확인하자 ! (mode, str, class)

x<-c(1:5) -- sequence로 표현할 경우 integer로 나온다.
y<-c(1,2,3,4,5) -- 직접 입력할 시 실수형으로 나온다.

> setequal(x,y)
[1] TRUE
> identical(x,y) -- identical은 type까지 맞아야한다.
[1] FALSE

# as.integer() -- 실수형을 정수형으로 바꿔주는 함수 <형 변환 함수>

예)
y<-as.integer(y)
> identical(x,y)
[1] TRUE

# help(method) / ?method이름 - 설명

# list
 
- 서로 다른 데이터 타입을 갖는 벡터들을 저장하거나 또 다른 리스트 저장가능한 구조이다.
- list(키 = 값, 키 = 값)

> x<-list(name = '홍길동', addr = '서울시', pn = '010-1111-1234') 
> x
$`name`
[1] "홍길동"

$addr
[1] "서울시"

$pn
[1] "010-1111-1234"

> str(x)
List of 3
 $ name: chr "홍길동"
 $ addr: chr "서울시"
 $ pn  : chr "010-1111-1234"

> class(x)
[1] "list"
> mode(x)
[1] "list"

-조작하는 법
< 값을 뽑아내는 방법>
x$name (x$키값)
x$addr
x$pn

x[1] - 요소번호 (키 값까지나옴)
x[[1]] - value 값만 나옴

> x[1]
$`name`
[1] "홍길동"

> x[[1]]
[1] "홍길동"

> x[1:3]
$`name`
[1] "홍길동"
$addr
[1] "서울시"
$pn
[1] "010-1111-1234"

# list에 요소를 추가하는 방법 -- 변수이름$키이름<-입력
> x$sal<-10000
> x
$`name`
[1] "홍길동"
$addr
[1] "서울시"
$pn
[1] "010-1111-1234"
$sal
[1] 10000

# list요소 제거 
x$sal <- NULL
> x$sal <- NULL
> x
$`name`
[1] "홍길동"
$addr
[1] "서울시"
$pn
[1] "010-1111-1234"


# list요소값을 수정

x$pn <- '010-1234-1004'
> x[[3]]
[1] "010-1234-1004"

# list 중첩

> y <- list(a=list(val=c(1,2,3)),b=list(val=c(1,2,3,4)))
> y
$`a`
$`a`$`val`
[1] 1 2 3
$b
$b$`val`
[1] 1 2 3 4

> y$a
$`val`
[1] 1 2 3

> y$b
$`val`
[1] 1 2 3 4

