[문제1] x변수에 1,3,5,7,9 값을 입력, y 변수에 1,2,3,4,5 값을 입력하세요.

x<-c(1,3,5,7,9)
y<-c(1,2,3,4,5)
x<-seq(1,9,2)
y<-seq(1,5,1)
y<-c(1:5)

[문제2] x 변수와 y 변수를 중복성 없이 하나로 합친후에 u 변수에 넣어 주세요.

u<-union(x,y) -- 정렬이 되어 있지 않다.

# sort : 정렬을 하는 함수 , 기준: 오름차순

u<-sort(union(x,y))

u<-sort(union(x,y),decreasing=TRUE) -- 내림차순

[문제3] x 변수와 y 변수의 값들중에 중복성만 추출해서 i 변수에 넣어주세요.

i<-intersect(x,y)

[문제4] x 변수의 값과 y 변수의 값중에 순수하게 x 변수에 들어 있는 값만 추출해서 m 변수에 넣어 주세요.

m<-setdiff(x,y) 

[문제5] x 변수의 값과 y 변수의 값이 일치가 되면 TRUE 아니면 FALSE를 출력해주세요.

setequal(x,y) - 개별로 비교

x==y

identical(x,y) - 덩어리로 비교

[문제6] x 변수에 값들을 10을 곱한 결과를 x 변수에 적용하세요.

x<-x*10

[문제7] x 변수에 있는 50을 5로 수정하세요.

x[3]<-5

x[which(50==x)] <- 5

[문제8]  x 변수에 있는 10 30  5 70 90을  원래의 값으로 1,3,5,7,9로 되돌려 주세요.단 union, 정수 나누기, sort 만 사용하세요

x<-sort(union(x[-3] %/% 10, x[3]))

x[-3] -> 제외를 하고
나머지 10으로 나눠서 1 3 7 9 를 만든후
x[3] 을 다시 추가해서 sort한다.

[문제9] x변수에 11숫자를 제일 뒤에 입력하세요. 단 append와 length를 이용하세요.

x<-append(x,11,after=length(x))

[문제10] x 변수에 제일 뒤에 있는 값을 NA로 수정하세요. 단 length를 이용하세요.

x<-append(x,NA,after=length(x))

[문제11] lst 변수에 name = 'king' , height = 180, weight = 70 값을 넣어 주세요.

lst<-list(name<-'king',height<-180,weight<-70)

[문제12] lst 변수에  blood = 'A' 추가하세요.

lst$blood<-'A'

[문제13] lst 변수에 name의 값을 'scott'로 수정하세요.

lst$name<-'scott'

[문제14] lst변수에 2번인덱스 값만 출력해주세요.

lst[[2]]

[문제15] lst변수에 blood 이름을 blood_type 이름으로 수정하세요.

lst$'blood type'<-lst$blood

[문제16] x 변수에 벡터값 1,2,3,5,6 을 입력한 후 3번째 요소 뒤에 4를 입력하세요.

x<-c(1,2,3,5,6)

x<-append(x,4,after=3)

[문제17] 1부터  3씩 증가하는 10 이하의 정수값을 출력하세요.

x<-seq(1,10,3)

x<-seq(1,10,length.out=20)

length.out->처음부터 끝값 사이의 수들을 갯수에 맞춰 뽑아주는 함수
# ->  주석문자

[문제18] 10 부터 20 까지의 값을 x 변수에 생성한 후 원소의 값이 15 이상이고 18 이하인 값들만 출력하세요.

x<-c(10:20)

x<-x[which(x>=15&x<=18)]

x<-x[x>=15&x<=18] # True인 요소를 뽑아낸다.

[문제19] 10 부터 20 까지의 값을 x 변수에 생성한 후 원소의 값이 15 이상이고 18 이하인 값들만 2곱한 값으로 수정하세요.

x<-c(10:20)

x[which(x>=15&x<=18)]<-x[which(x>=15&x<=18)]*2

[문제20] x 변수에 행렬을 구성하세요. 값은 1부터 10까지 입력하시고 5행 2열으로 만들면서 값은 열을 기준으로 생성하세요.

x<-matrix(1:10,nrow=5)
x<-matrix(1:10,nrow=5,ncol=2,byrow=FALSE)

[문제21] x 변수에 열을 기준으로 11,12,13,14,15 값을 추가하세요.

x<-cbind(x,c(11,12,13,14,15))

[문제22] x 변수에 행을 기준으로 16,17,18 값을 추가하세요.

x<-rbind(x,c(16,17,18))

[문제23] x변수에 6행의 값을 20,21,22 로 수정하세요.

x[6,]<-c(20,21,22)

[문제24] x 변수에 6행을 제거해주세요.

x<-x[-6,]

[문제25] x 배열을 생성하세요. 1부터 12까지 값을 가지고있는 배열을 생성하세요. 면은 3개가 만들어지도록하세요.

x<-array(c(1:12),dim=c(2,2,3))

[문제26] x 배열 변수에 컬럼이름은 'a','b'로 설정하세요.

colnames(x)<-c("a","b")

[문제27] x 배열 변수에 행이름은 'row1','row2'로 설정하세요.

rownames(x)<-c("row1","row2")

[문제28] x 배열 변수에 면을 2로 수정하세요.

dim(x)<-c(2,3,2)
dim(x)<-c(3,2,2)
dim(x)<-c(6,1,2)
dim(x)<-c(1,6,2)

[문제29] 벡터에 있는 값 "large", "medium", "small", "small", "large", "medium" 을 factor 변수로 구성하세요. 변수이름은
          x로 생성하시고 levels small, medium, large 순으로 지정하세요.

x<-factor(c("large", "medium", "small", "small", "large", "medium"),levels=c("small","medium","large"))

[문제30] x factor형 목록이름중에 small 을 s로 수정하세요.

levels(x)[1]<-"s"

levels(x)[levels(x)=="small"] <- "s"

[문제31] 아래와 같은 모양의 변수를 생성하세요. 변수 이름은 df로 하세요.

<화면출력>

> df
   name sql  plsql
1  king  96     75
2 smith  82     91
3  jane  78     86

df<-data.frame(name=c("king","smith","jane"),sql=c(96,82,78),plsql=c(75,91,86),stringsAsFactors=FALSE)

[문제32] df변수에 james, 90, 80 추가 해주세요.

<화면출력>

> df
   name sql plsql
1  king  96    75
2 smith  82    91
3  jane  78    86
4 james  90    80

df[4,]<-c(james,90,80)
df<-rbind(df,c('james',90,80))
df<-rbind(df,data.frame(name='james',sql=90,plsql=80)

[문제33] james에 대한 row 정보만 출력하세요.

<화면출력>

   name sql plsql  r
4 james  90    80 60

df$name=='james'  
df[df$name=='james',]

[문제34] emp 변수에 있는 데이터 중에 급여가 3000 인 사원들의 last_name, salary를 출력하세요. 단 emp 변수에 컬럼정보를 확인하시고 수행하세요.

emp<-read.csv("emp.csv",header=TRUE ,stringsAsFactors=FALSE)
str(emp)
names(emp)

desc employees
select last_name, salary from employees where salary=3000;

emp[emp$SALARY==3000,c('LAST_NAME','SALARY')]

[문제35] 급여가 2000 이상인 사원들의 last_name, salary를 출력하세요.

select last_name,salary from employees where salary>=2000;

emp[emp$SALARY>=2000,c('LAST_NAME','SALARY')]

[문제36] job이 ST_CLERK인 사원들의 이름과 월급과 직업을 출력하세요.

select last_name,salary,job_id from employees where job_id='ST_CLERK';

emp[emp$JOB_ID=='ST_CLERK',c('LAST_NAME','SALARY','JOB_ID')]

[문제37] job이 ST_CLERK이 아닌 사원들의 이름과 월급과 직업을 출력하세요.

select last_name,salary,job_id from employees where job_id<>'ST_CLERK';

emp[emp$JOB_ID!='ST_CLERK',c('LAST_NAME','SALARY','JOB_ID')]

[문제38] 오라클의 in 연산자와 비슷한 R연산자는?

%in% -- 값이 일치하면 TRUE/FALSE를 뽑아냄 

[문제39] job이 AD_ASST, MK_MAN 인 사원들의 employee_id,last_name,job_id를 출력하세요.

select employee_id, last_name, job_id from employees where job_id in ('AD_ASST','MK_MAN');

emp[emp$JOB_ID=='AD_ASST'| emp$JOB_ID=='MK_MAN',c('EMPLOYEE_ID','LAST_NAME','JOB_ID')]

emp[emp$JOB_ID %in% c('AD_ASST','MK_MAN'),c('EMPLOYEE_ID','LAST_NAME','JOB_ID')]

[문제40] job이 ST_CLERK, SH_CLERK, SA_REP 아닌 사원들의 employee_id,last_name,job_id를 출력하세요.

select employee_id,last_name,job_id from employees where job_id not in ('ST_CLERK', 'SH_CLERK', 'SA_REP');

emp[emp$JOB_ID!='ST_CLERK' & emp$JOB_ID!='SH_CLERK' & emp$JOB_ID!='SA_REP' ,c('EMPLOYEE_ID','LAST_NAME','JOB_ID')]

emp[!emp$JOB_ID %in% c('ST_CLERK', 'SH_CLERK', 'SA_REP'),c('EMPLOYEE_ID','LAST_NAME','JOB_ID')]

- ★★ not in 은 존재하지 않기 때문에 값을 부정으로 해서 구한다.

[문제41] 부서번호가 10번,20번인 사원들의 last_name, salary, department_id를 출력하세요.

select last_name, salary, department_id from employees where department_id in (10,20);       

emp[emp$DEPARTMENT_ID==10 | emp$DEPARTMENT_ID==20, c('LAST_NAME','SALARY','DEPARTMENT_ID')]

emp[emp$DEPARTMENE_ID %in% c(10,20), c('LAST_NAME','SALARY','DEPARTMENT_ID')]

[문제42] 오라클의 연결 연산자 와 비슷한 R 연산자는?
               
	  오라클		 R
            ||   		paste

예)paste(,,,,)

[문제43] 아래결과와 같이 출력되도록하세요. 

Grant 의 직업은  SH_CLERK  입니다.

select last_name||' 의 직업은 '||job_id||' 입니다.' from employees;

paste(emp$LAST_NAME,' 의 직업은 ',emp$JOB_ID,' 입니다.')
paste(emp$LAST_NAME,'의 직업은',emp$JOB_ID,'입니다.',sep="") -- 띄어쓰기 없애는 방법 (sep)

# 순서가 동일하기 때문에 값이 나오는거지 저 LAST_NAME에 맞는 JOB_ID가 바로 나오는것은 아니다.

[문제44] R에서 NA(결측치)를 체크하는 함수는?

is.na()

[문제45] commission_pct에  NA 인 사원들의 last_name, salary, commission_pct를 출력하세요.

select last_name,salary,commision_pct from employees where commission_pct is null;

emp[is.na(emp$COMMISSION_PCT),c('LAST_NAME','SALARY','COMMISSION_PCT')]

[문제46] department_id에 NA 인 사원들의 last_name, salary, department_id를 출력하세요.

select last_name,salary,department_id from employees where department_id is null;

emp[is.na(emp$DEPARTMENT_ID),c('LAST_NAME','SALARY','DEPARTMENT_ID')]

[문제47] commission_pct에  NA가 아닌 사원들의 last_name, salary, commission_pct를 출력하세요.

select last_name, salary, commission_pct from employees where commission_pct is not null;

emp[!is.na(emp$COMMISSION_PCT),c('LAST_NAME','SALARY','COMMISSION_PCT')]

[문제48] 30번 부서 사원들이면서 급여는 3000이상인 사원들의 employee_id, salary, department_id를 출력하세요.

select employee_id, salary, department_id from employees where department_id=30 and salary>=3000

emp[which(emp$DEPARTMENT_ID==30 & emp$SALARY>=3000),c('EMPLOYEE_ID','SALARY','DEPARTMENT_ID')]

# na.omit - na row를 없애주는 함수

na.omit(emp[emp$DEPARTMENT_ID==30 & emp$SALARY>=3000,c('EMPLOYEE_ID','SALARY','DEPARTMENT_ID')])

-- which를 쓰면 na가 없어지니까 which를 사용한다.

# 파일 안에 있는 데이터는 비정형 데이터이다. 정해진 데이터의 조건이 없다. 그리고 na가 있으면 어떠한 값이라고 넣을 수 있기 때문에 na 뜨는것이라고 생각이 든다. 
  그리고 무조건 na에 있다고 뜨는 것이 아니라 na에 해당되는 값이 조건에 맞을 때만 na가 뜬다.

[문제49] 20번부서 사원이면서 급여는 10000를 초과한 사원 또는 급여가 2500 미만의 사원들의 employee_id, salary, department_id를 출력하세요.

select employee_id, salary, department_id from employees where (department_id=20 and salary>10000) or salary<2500;

emp[(emp$DEPARTMENT_ID==20 & emp$SALARY>10000) | emp$SALARY<2500,c('EMPLOYEE_ID','SALARY','DEPARTMENT_ID')]

■ grep함수 : 문자 패턴을 찾을 때 사용되는 함수 

       ^ : 첫번째 
       $ : 마지막
       . : 한자리수
       * : wild card(%)

<예>
emp[grep("aa", emp$LAST_NAME),c("LAST_NAME","SALARY")]

emp[grep("[x-z]", emp$LAST_NAME, ignore.case = TRUE),c("LAST_NAME","SALARY")] -- x부터 z까지의 글자 어느위치든 가능

ignore.case = TRUE 대소문자 구분안한다.
ignore.case = FALSE 대소문자 구분한다.

[문제50]last_name의 첫번째 글자가 A 로 시작하는 사원들의 last_name, salary를 출력하세요.

select last_name, salary from employees where last_name like 'A%';

emp[grep("^A",emp$LAST_NAME,ignore.case=FALSE),c('LAST_NAME','SALARY')]

emp[grep("^A.*",emp$LAST_NAME,ignore.case=FALSE),c('LAST_NAME','SALARY')]

# ^A* 에선 되지 않는다. 

[문제51]last_name의 끝글자가 g 로 끝나는 사원들의 last_name, salary를 출력하세요.

select last_name, salary from employees where last_name like 'g%';

emp[grep("g$",emp$LAST_NAME,ignore.case=FALSE),c('LAST_NAME','SALARY')]
emp[grep("*g$",emp$LAST_NAME,ignore.case=FALSE),c('LAST_NAME','SALARY')]
emp[grep("*.g$",emp$LAST_NAME,ignore.case=FALSE),c('LAST_NAME','SALARY')]

[문제52]last_name의 z 를 포함하고 있는 사원들의 last_name, salary를 출력하세요.

select last_name, salary from employees where last_name like '%z%';

emp[grep("z",emp$LAST_NAME,ignore.case=FALSE),c('LAST_NAME','SALARY')]

emp[grep("^*.z.*$",emp$LAST_NAME,ignore.case=FALSE),c('LAST_NAME','SALARY')]

[문제53]last_name의 두번째 철자가 u 인 사원들의 last_name, salary를 출력하세요.

select last_name, salary from employees where last_name like '_u%';

emp[grep("^.u",emp$LAST_NAME,ignore.case=FALSE),c('LAST_NAME','SALARY')]

emp[grep("^.u.*",emp$LAST_NAME,ignore.case=FALSE),c('LAST_NAME','SALARY')]

[문제54] developer글자를 첫글자 대문자, 뒤글자는 소문자로 변환하세요.

paste(toupper(substr('developer',1,1)),substr('developer',2,8),tolower(substr('developer',9,9)),sep="")

paste(toupper(substr('developer',1,1)),substr('developer',2,nchar('developer')-1),tolower(substr('developer',nchar('developer'),nchar('developer'))),sep="")

paste(toupper(substr('developer',1,1)),tolower(substr('developer',2,nchar('developer'))),sep="")

library(tools) -- 라이브러리 불러오기
toTitleCase("developer") -- 함수이름 

install.packages('stringr') -- 패키지 다운로드
library(stringr) -- 라이브러리 불러오기
str_to_title('developer') -- 함수이름

[문제55] last_name의 글자의 수가 10이상인 사원의 employee_id, last_name 출력하세요.

select employee_id, last_name from employees where length(last_name)>=10;

emp[nchar(emp$LAST_NAME)>=10,c('EMPLOYEE_ID','LAST_NAME')]

[문제56] last_name, last_name의 첫번째 철자부터 세번째 철자까지 함께 출력하세요.

select last_name, substr(last_name,1,3) from employees;

data.frame(emp$LAST_NAME,substr(emp$LAST_NAME,1,3))
paste(emp$LAST_NAME,substr(emp$LAST_NAME,1,3))

[문제57] last_name의 두번째 철자가 m  인 사원들의 last_name, salary를 출력하세요.

select last_name,salary from employees where last_name like '_m%';

emp[substr(emp$LAST_NAME,2,2)=='m',c('EMPLOYEE_ID','LAST_NAME')]
emp[grep("^.m", emp$LAST_NAME),c("EMPLOYEE_ID","LAST_NAME")]

[문제58] last_name의 두번째 철자가 m 또는 g 인 사원들의 last_name, salary를 출력하세요.

select last_name,salary from employees where last_name like '_m%' or last_name like '_g%';

emp[substr(emp$LAST_NAME,2,2) %in% c('m','g'),c('EMPLOYEE_ID','LAST_NAME')]
emp[grep("^.m|^.g", emp$LAST_NAME),c("LAST_NAME","SALARY")]
emp[grep("^.(m|g)", emp$LAST_NAME),c("LAST_NAME","SALARY")]
emp[grep("^.[m|g]", emp$LAST_NAME),c("LAST_NAME","SALARY")]
emp[c(grep('^.m', emp$LAST_NAME),grep('^.g', emp$LAST_NAME)),c("LAST_NAME","SALARY")]
emp[grepl('^.m', emp$LAST_NAME)|grepl('^.g', emp$LAST_NAME),c("LAST_NAME","SALARY")]

# grep은 값 추출이 숫자로 되기 때문에 | 를 사용해서 값을 구하면 boolean으로 바뀐다. 따라서 밖에서 연산자를 사용하게 되면 값을 구할 수 없다.

1. grep '|' 안에 쓰던가

2. grepl : logical 함수라서 기존에 방법으로 | 을 사용하면 가능하다.

[문제59] last_name, salary값을 화면에 출력할때 0은 * 로 출력하세요.

select last_name,replace(salary,0,'*') from employees; 

paste(emp$LAST_NAME,gsub(0,'*',emp$SALARY))
data.frame(emp$LAST_NAME,gsub(0,'*',emp$SALARY))

[문제60] last_name의 제일 뒷글자만 대문자 앞글자들은 소문자로 출력하세요.

select initcap(last_name) from employees;

paste(tolower(substr(emp$LAST_NAME,1,nchar(emp$LAST_NAME)-1)),toupper(substr(emp$LAST_NAME,nchar(emp$LAST_NAME),nchar(emp$LAST_NAME))),sep="")

[문제61] s 백터 변수를 생성해서 "BIG DATA MARKETING" 입력한 후 단어로 분리해주세요.

s<-c("BIG DATA MARKETING")

unlist(strsplit(s,split=" "))

create or replace function a
(p_char in varchar2)
return varchar2
is
	type q is table of varchar2 index by pls_integer;
	e q;
	v_num number;
	v_a varchar2
begin
	select substr(p_char,1,1),length(p_char)
	into v_a,v_num 
	from dual;

	for i in 1..v_num loop
		if v_a=" " then	
			
		else 
			e(i):=v_a;
			select substr(p_char,i+1,1)
			into 	
		
	end loop;
end; 
/

begin

dbms_output.put_line(a("BIG DATA MARKETING"))'
end;
/

[문제62] 2002-06-07에 입사한 사원들의 last_name, hire_date를 출력하세요.

select last_name, hire_date from employees where hire_date=to_date('2002-06-07','yyyy-mm-dd');

emp[emp$HIRE_DATE==20020607,c('LAST_NAME','HIRE_DATE')]
emp[as.Date(as.character(emp$HIRE_DATE),format='%Y%m%d') ==as.Date('2002-06-07'),c('LAST_NAME','HIRE_DATE')]

[문제63] 사원의 last_name, 근무일수를 출력하세요.

select last_name, trunc(months_between(sysdate,hire_date)*30) from employees ;       

data.frame(last_name=emp$LAST_NAME, working_days=as.numeric(Sys.Date()-as.Date(as.character(emp$HIRE_DATE),format='%Y%m%d')))
difftime(Sys.Date(),as.Date(as.character(emp$HIRE_DATE),format='%Y%m%d'))

[문제64] 사원의 last_name, 입사한 요일을 출력하세요.

select last_name, to_char(hire_date,'day') from employees;

format(as.Date(as.character(emp$HIRE_DATE),format='%Y%m%d'),'%A')

수정을 해놓고 하면 더 편하다.

emp$HIRE_DATE <- as.Date(as.character(emp$HIRE_DATE),format='%Y%m%d')

[문제65] 오늘 날짜를 기준으로  100개월 되는 날짜의 요일을 출력하세요.
 
select to_char(add_months(sysdate,100),'day') from dual;

format(Sys.Date()+months(100),'%A')
weekdays(Sys.Date() + months(100))

wday(Sys.Date() + months(100),label=T)

[문제66] 부서번호를 중복 제거해주세요

na.omit(unique(emp$DEPARTMENT_ID))

 [1]  50  10  20  40  70 110  90  60 100  30  80
attr(,"na.action")
[1] 12
attr(,"class")
[1] "omit"

as.integer(na.omit(unique(emp$DEPARTMENT_ID)))
 [1]  50  10  20  40  70 110  90  60 100  30  80

[문제67] last_name, hire_date를  출력하는데 먼저 입사한 사원부터 출력하세요.

select last_name, hire_date from employees order by hire_date ;

library(doBy) - 오름차순,내림차순 해주는 함수 생성

orderBy(~HIRE_DATE,emp[,c("LAST_NAME","HIRE_DATE")])
emp[order(emp$HIRE_DATE),c("LAST_NAME","HIRE_DATE")]

[문제68] df이름의 data frame 변수를 선언합니다.
id 컬럼의 값은 100,101,102,103,104,  
weight 컬럼의 값은 60,90,75,95,65, 
size 컬럼의 값은 small, large, medium,large,small 값으로 생성하세요.

df<-data.frame(id=c(100,101,102,103,104),weight=c(60,90,75,95,65),size=c("small","large","medium","large","small"))

[문제69] df변수에 weight 컬럼을 기준으로 오름차순 정렬해서 df 변수에 값을 출력하세요.(order 함수를 이용하세요)

df[order(df$weight),]

df$weight<-df$weight[order(df$weight,decreasing=FALSE)]
df
   id weight   size
1 100     60  small
2 101     65  large
3 102     75 medium
4 103     90  large
5 104     95  small

[문제70] df변수에 size, weight 컬럼을 기준으로 오름차순 정렬하세요.(order 함수를 이용하세요)

df[order(df$size,df$weight),]

   id weight   size
2 101     90  large
4 103     95  large
3 102     75 medium
1 100     60  small
5 104     65  small

[문제71] df 변수에 있는 weight 컬럼을 기준으로 내림차순 정렬하세요.(order 함수를 이용하세요)

df[order(df$weight,decreasing=TRUE),]
df[order(-df$weight),] -- 각각 오름차순 내림차순을 표현하고 싶다면 +,-를 사용하는 것이 좋다.

df$weight<-df$weight[order(df$weight,decreasing=TRUE)]
df
   id weight   sizs
1 100     95  small
2 101     90  large
3 102     75 medium
4 103     65  large
5 104     60  small

[문제72] 30번 부서 사원들의 last_name, salary를  출력하세요.
         단 salary를 기준으로 내림차순정렬하세요.
	
select last_name, salary from employees where department_id=30 order by salary desc;
	
library(doBy) -- orderBy 사용
orderBy(~-SALARY,na.omit(emp[emp$DEPARTMENT_ID==30,c("LAST_NAME","SALARY")]))


[문제73] job_id가  ST_CLERK 가 아닌 사원들의 last_name, salary, job_id를 출력하는데 급여가 높은 사원부터 출력되게하세요.(orderBy 함수를 이용하세요)

select last_name, salary, job_id from employees where job_id<>'ST_CLERK' order by salary;

orderBy(~-SALARY,emp[!emp$JOB_ID=="ST_CLERK",c("LAST_NAME","SALARY","JOB_ID")])
orderBy(~-SALARY,emp[emp$JOB_ID!="ST_CLERK",c("LAST_NAME","SALARY","JOB_ID")])

[문제74] 사원 last_name, salary, commission_pct를 출력하는데 commission_pct를 기준으로 오름차순정렬하세요.(orderBy를 이용하세요)

select last_name, salary, commission_pct from employees order by commission_pct;

orderBy(~COMMISSION_PCT,emp[,c("LAST_NAME","SALARY","COMMISSION_PCT")])

[문제75] commission_pct를 받고 있는 사원들의 last_name, salary, commission_pct를 출력하는데 commission_pct를 기준으로 오름차순정렬하세요.(orderBy를 이용하세요)

select last_name,salary, commission_pct from employees where commission_pct is not null;

orderBy(~COMMISSION_PCT,emp[!is.na(emp$COMMISSION_PCT),c("LAST_NAME","SALARY","COMMISSION_PCT")])
orderBy(~COMMISSION_PCT,emp[na.omit(emp$COMMISSION_PCT),c("LAST_NAME","SALARY","COMMISSION_PCT")])

[문제76] 6의 9승을 출력하세요 

select power(6,9) from dual;

6**9 6^9

[문제77] 10을 3으로 나눈 나머지값을 출력하세요 

select mod(10,3) from dual;

10%%3

[문제78] last_name, salary에 12를  곱해서 출력하고 컬럼명이 한글로 연봉으로  데이터 프레임으로 출력하세요 

select last_name,salary*12 as "연봉" from employees;

x<-data.frame("이름"=emp$LAST_NAME,"연봉"=emp$SALARY*12)

[문제79] last_name과 연봉을 출력하는데 연봉이 높은것부터 출력하세요 

select last_name,salary*12 as "연봉" from employees order by salary*12 desc;

orderBy(~-연봉,data.frame("이름"=emp$LAST_NAME,"연봉"=emp$SALARY*12))
x[order(-x$연봉),]

[문제80] 문제79를 round 함수를 이용해서 아래와 같이 백단위에서 반올림되게 하세요. 

select last_name,round(salary*12,-3) as "연봉" from employees order by round(salary*12,-3) desc;
  
 4:  JONES 35700  ----->  36000

orderBy(~-연봉,data.frame("이름"=emp$LAST_NAME,"연봉"=round(emp$SALARY*12,-3)))

x$연봉<-(round(x$연봉,-3))
x[order(-x$연봉),]

[문제81] 최대월급을 출력하세요

select max(salary) from employees;

max(emp$SALARY)

[문제82] 직업이 ST_CLERK 인 사원들중에 최대월급을 출력하세요

select max(salary) from employees where job_id='ST_CLERK'

max(emp[emp$JOB_ID=='ST_CLERK',c("SALARY")])

[문제83] 부서번호별로 급여에 총액을 출력하세요.
 
select department_id, sum(salary) from employees group by department_id;

aggregate(SALARY~DEPARTMENT_ID,emp,sum)

[문제84] 부서번호, 직업별로 급여에 총액을 출력하세요.

select department_id,job_id,sum(salary) from employees group by department_id,job_id;

aggregate(SALARY~DEPARTMENT_ID+JOB_ID,emp,sum)

[문제85] 부서번호별 최대월급을 출력하는데 최대월급이 높은것부터 출력하세요.

select department_id,max(salary) from employees group by department_id order by max(salary) desc;

library(doBy)
orderBy(~-SALARY,aggregate(SALARY~DEPARTMENT_ID,emp,max))

[문제86] 직업별 인원수를 출력하세요.

select job_id, count(*) from employees group by job_id;

aggregate(EMPLOYEE_ID~JOB_ID,emp,length) 
aggregate(EMPLOYEE_ID~JOB_ID,emp,NROW) 

[문제87] 아래화면의 결과 처럼 데이터 프레임을 생성한 후 
total 컬럼을 생성해서 sql과 python 의 합을 구하세요.(단 apply함수를 이용하세요)

name 	sql 	python
king	96	75
smith	NA	91
jane	78	86
scott	90	NA

create table data 
(name varchar(50), 
sql number(10),
python number(10)
) tablespace users;

insert into data(name) values('king','smith','jane','scott')
insert into data(sql) values(96,null,78,90)
insert into data(python) values(75,91,86,null)

alter table data add total number(10);

insert all 
into data(total)
values(sql+python)
select sql+python
from data;

x<-data.frame(name=c("king","smith","jane","scott"),sql=c(96,NA,78,90),python=c(75,91,86,NA))
x
total<-apply(x[,c(2:3)],1,sum,na.rm=TRUE)
total
x<-cbind(x,total)

   name sql python total
1  king  96     75   171
2 smith  NA     91    91
3  jane  78     86   164
4 scott  90     NA    90

[문제88] 입사한 년도별 평균월급을 세로(aggregate), 가로(tapply)로 출력하세요.

select decode(year,'2001',avgsal) as "2001",
	decode(year,'2002',avgsal) as "2002",
	decode(year,'2003',avgsal) as "2003",
	decode(year,'2004',avgsal) as "2004",
	decode(year,'2005',avgsal) as "2005"
from (select to_char(hire_date,'yyyy') year, avg(salary) avgsal
	from employees
	group by rollup(to_char(hire_date,'yyyy')));

emp$HIRE_DATE<-as.Date(as.character(emp$HIRE_DATE),format='%Y%m%d')
format(emp$HIRE_DATE,'%Y') -- 연도생성

year<-as.numeric(substr(emp$HIRE_DATE,1,4))

aggregate(SALARY~year,emp,mean)
tapply(emp$SALARY,year,mean)

[문제89] 부서별 인원수를 세로(aggregate), 가로(tapply)로 출력하세요.

select department_id, count(*)
from employees
group by department_id;

select case when department_id=10 then aa end as "10",
       case when department_id=20 then aa end as "20"
from (select department_id, count(*) aa
	from employees
	group by department_id);

aggregate(EMPLOYEE_ID~DEPARTMENT_ID,emp,NROW)
aggregate(EMPLOYEE_ID~DEPARTMENT_ID,emp,length)
tapply(emp$EMPLOYEE_ID,emp$DEPARTMENT_ID,length)

[문제90]job_id, hire_date(년도4자리) 총액 급여를 aggregate함수를 이용해서 생성하세요.

select job_id, to_char(hire_date,'yyyy'), sum(salary)
from employees
group by job_id, to_char(hire_date,'yyyy');

aggregate(SALARY~JOB_ID+year,emp,sum,na.ra=TRUE)

[문제91] job_id, hire_date(년도4자리) 총액 급여를 tapply함수를 이용해서 생성하세요.
단 NA 대신에 0 으로 출력하세요. - pivot table 구조


select ad,decode(year,'2001',sumsal) as "2001"
from (select job_id ad, to_char(hire_date,'yyyy') year, sum(salary) sumsal
	from employees
	group by job_id,to_char(hire_date,'yyyy'));

tapply(emp$SALARY,list(emp$JOB_ID,year),sum,na.rm=TRUE,default=0)

temp$HIRE_DATE<-as.Date(as.character(emp$HIRE_DATE),format='%Y%m%d')
t<-tapply(emp$SALARY,data.frame(emp$JOB_ID,format(emp$HIRE_DATE,'%Y')),sum)
t[is.na(t)==TRUE]<-0
t

[문제92] 변수에 2를 입력한 후 그 변수에 값이 2의 배수이면 "2의 배수" 출력
	아니면 "2의 배수가 아니다" 출력해주세요.
	if문, ifelse함수로 수행해주세요.


var b_num number
exec :b_num := 2;
 	
begin 
	if :b_num=2 then
		dbms_output.put_line('2의 배수');
	else
		dbms_output.put_line('2의 배수가 아니다.');
	end if;
end;
/

x<-2
if (x%%2==0){
		print("2의 배수")
	    }else
	    {
		print("2의 배수가 아니다.")
	    }

ifelse(x%%2==0,print("2의 배수"),print("2의 배수가 아니다.")) -- 함수가 리턴이 되서 값이 2번 나온다.

ifelse(x%%2==0,c("2의 배수"),c("2의 배수가 아니다"))
ifelse(x%%2==0,"2의 배수","2의 배수가 아니다")

[문제93] emp 변수에 있는 데이터를 가지고 새로운 df변수를 생성하세요.
last_name, salary, 급여가 10000  이상이면 A, 5000이상 10000보다 작으면 B 나머지는 C가 입력되어 있는 새로운 컬럼을 생성하세요.  
컬럼이름은 name, sal, level 로 설정하세요.

create or replace function grade_sal
(p_id in number)
return varchar2
is
begin
	if p_id>=10000 then 
		return 'A';
	elsif p_id>=5000 and p_id<10000 then
		return 'B';
	else
		return 'C';
	end if;
end;
/


select last_name,salary,grade_sal(salary)
from employees;

df<-data.frame(name=emp$LAST_NAME,sal=emp$SALARY)
level<-ifelse(df$sal>=10000,"A",ifelse(df$sal>=5000,"B","C"))
df<-cbind(df,level)
df

[문제94] x 변수에 1부터 100까지 입력한 후 짝수값은 자신의 값에 10을 곱한 값으로 수정하세요.

declare
	type b_num is table of number index by pls_integer;
	v_num b_num;
begin 
	for i in 1..100 loop
		v_num(i):=i;
		if mod(v_num(i),2)=0 then
			v_num(i) := v_num(i) * 10;
		end if;
	end loop;
	
	for j in v_num.first..v_num.last loop
		dbms_output.put_line(v_num(j));
	end loop;
end;
/


x<-c(1:100)
x<-ifelse(x%%2==0,x*10,x)

x<-1:100
x[x%%2==0]<-x[x%%2==0]*10 -- index로 해결

[문제95]  x <- c(2,10,6,4,3,NA,7,9,1)  x변수에 NA가 있는지를 검사하세요.

declare
	type b_num is table of number;
	v_num b_num := b_num(2,10,6,4,3,null,7,9,1);
	a_num number;
	c_num number;
begin
	for i in v_num.first..v_num.last loop
		if v_num(i) is null then
			a_num := v_num(i);
			c_num := i;
		end if;
	end loop;

	if  a_num is not null then
		dbms_output.put_line('Null값이 없습니다.');
	else
		dbms_output.put_line(c_num || '번째에 ' || a_num ||' 값이 있습니다.');
	end if;
end;
/

x <- c(2,10,6,4,3,NA,7,9,1)
is.na(x)

[문제96] x 변수에 NA가 있는 인덱스 번호를 찾아 주세요.

which(is.na(x))

[문제97] x 변수에 NA가 있으면 0으로 설정하세요

declare
	type b_num is table of number;
	v_num b_num := b_num(2,10,6,4,3,null,7,9,1);
begin
	for i in v_num.first..v_num.last loop
		if v_num(i) is null then
			v_num(i) := 0;
		end if;
	end loop;

	for i in v_num.first..v_num.last loop
		dbms_output.put_line(v_num(i));
	end loop;
end;
/

x <- c(2,10,6,4,3,NA,7,9,1)
x<-ifelse(is.na(x)==TRUE,x[which(is.na(x))]<-0,x)
x

[문제98] last_name, salary, commission_pct, 
       commission_pct NA 면 salary * 12,
       아니면 (salary * 12) + (salary * 12 * commission_pct)을 수행하세요.

select last_name, salary, commission_pct, nvl2(commission_pct,(salary * 12) + (salary * 12 * commission_pct),salary * 12)
from employees;

> head(df)
       name   sal comm ann_sal
1  OConnell  2600   NA   31200
2     Grant  2600   NA   31200
3    Whalen  4400   NA   52800
4 Hartstein 13000   NA  156000
5       Fay  6000   NA   72000
6    Mavris  6500   NA   78000
> 

df<-data.frame(name=emp$LAST_NAME,sal=emp$SALARY,comm=emp$COMMISSION_PCT)
ann_sal<-ifelse(is.na(df$comm)==TRUE,df$sal*12,(df$sal * 12) + (df$sal * 12 * df$comm))
df<-cbind(df,ann_sal)
df

[문제99] x변수에 1부터 100까지 입력한 후
	1은 합을, 2는 평균, 3은 분산, 4는 표준편차를
	구하는 switch문을 생성하세요.

create or replace function carr
(p_id in number)
return number
is
	a_num number :=0;
	b_num number :=0;
	c_num number :=0;
	d_num number :=0;
begin

	for i in 1..100 loop
		a_num := a_num+i;		
	end loop;
	
	b_num := a_num/100;

	for j in 1..100 loop
		c_num := c_num+(j-b_num)*(j-b_num);
	end loop;

	c_num := c_num/100;

	for k in 1..100 loop
		d_num := d_num+(k-b_num);
	end loop;
	
	d_num := d_num/10;

	if p_id=1 then 
		return a_num;
	elsif p_id=2 then
		return b_num;
	elsif p_id=3 then
		return c_num;
	elsif p_id=4 then
		return d_num;
	else
		return '다시 입력하여 주십시오';
	end if;  	
end;
/

x<-c(1:100)
y<-1
switch(y,sum(x),mean(x),var(x),sd(x))

[문제100] 1부터 10까지 합을 for문을 이용해서 구하세요.

declare
	v_num number := 0;
begin
	for i in 1..10 loop
		v_num := v_num+i;
	end loop;
	
	dbms_output.put_line(v_num);
end;
/



x<-0
for (i in 1:10){
  x<-x+i
  print(x)
}
[1] 1
[1] 3
[1] 6
[1] 10
[1] 15
[1] 21
[1] 28
[1] 36
[1] 45
[1] 55

x<-1:10
for (i in x){x<-x+i}
x

[문제101] 1부터 100까지 전체 합,짝수 합, 홀수 합을 출력하세요

declare
	v_num number := 0;
	a_num number := 0;
	b_num number := 0;
begin
	for i in 1..100 loop
		v_num := v_num+i;
		if mod(i,2)=0 then
			a_num := a_num+i;
		else
			b_num := b_num+i;
		end if;
	end loop;
	
	dbms_output.put_line('총합: '||v_num);
	dbms_output.put_line('짝수 합: '||a_num);
	dbms_output.put_line('홀수 합: '||b_num);
end;
/

x<-0
y<-0
z<-0
for (i in 1:100){
	x<-x+i
	if(i%%2==0){y<-y+i}
	else{z<-z+i}
	}
> x
[1] 5050
> y
[1] 2550
> z
[1] 2500

m<-c(1:100)

[문제102] 1부터 100까지 짝수합, 홀수합을 tapply를 이용하여 구하세요.

m<-tapply(m,(m%%2==1),sum)
rownames(m)<-c('짝수','홀수')
m

[문제103] 1부터100까지 홀수만 x 변수에 입력해주세요.(for문을 이용하세요)

declare

	type a_num is table of number index by pls_integer;
	b_num a_num;
begin
	for i in 1..100 loop
		if mod(i,2)=1 then
			dbms_output.put_line(i);
		end if;
	end loop;	
end;
/


x<-NULL;
for (i in 1:100) {if (i%%2==1) {x<-append(x,i,length(x))}}
x


x<-NULL; y<-NULL; z<-NULL; r<-NULL; 
for (i in 1:100) {if (i%%2==1) {
                                print(paste(i,'홀수'))
                                x<-append(x,i,length(x))
                                y<-c(y,i)
                                z<-cbind(z,i)
                                r<-rbind(r,i)
                                }
                  }

> str(r)
 int [1:50, 1] 1 3 5 7 9 11 13 15 17 19 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:50] "i" "i" "i" "i" ...
  ..$ : NULL
> str(z)
 int [1, 1:50] 1 3 5 7 9 11 13 15 17 19 ...
 - attr(*, "dimnames")=List of 2
  ..$ : NULL
  ..$ : chr [1:50] "i" "i" "i" "i" ...
> str(y)
 int [1:50] 1 3 5 7 9 11 13 15 17 19 ...
> str(x)
 int [1:50] 1 3 5 7 9 11 13 15 17 19 ...

[문제104] while문을 이용해서 2단을 출력하세요.

var b_dan number

exec :b_dan:=2

declare

	i number :=0;

begin 
	while i<9 loop
		i := i+1;
		dbms_output.put_line(:b_dan||' * '||i||' = '||:b_dan*i);
	end loop;
end;
/
		

[1] "2 x 1 = 2"
[1] "2 x 2 = 4"
[1] "2 x 3 = 6"
[1] "2 x 4 = 8"
[1] "2 x 5 = 10"
[1] "2 x 6 = 12"
[1] "2 x 7 = 14"
[1] "2 x 8 = 16"
[1] "2 x 9 = 18"

i<-1
while(i<=9){ 
            print(paste("2 x",i,"=",2*i)) 
            i<-i+1
            }

[문제105] repeat문을 이용해서 2단을 출력하세요.

declare
	i number :=0;
begin
	loop
		i:=i+1;
		dbms_output.put_line(:b_dan||' * '||i||' = '||:b_dan*i);
	exit when i>8;
	end loop;
end;
/

[1] "2 x 1 = 2"
[1] "2 x 2 = 4"
[1] "2 x 3 = 6"
[1] "2 x 4 = 8"
[1] "2 x 5 = 10"
[1] "2 x 6 = 12"
[1] "2 x 7 = 14"
[1] "2 x 8 = 16"
[1] "2 x 9 = 18"

i<-1
repeat{
	if(i==10){break}
	print(paste("2 x",i,"=",2*i))
	i<-i+1
	} 

[문제106] x변수에 1부터 10까지 입력한 후 홀수인지 짝수인지를 출력하세요.


1  2  3  4  5  6  7  8  9 10


"홀수" "짝수" "홀수" "짝수" "홀수" "짝수" "홀수" "짝수" "홀수" "짝수"

declare
	type a_num is table of number;
	b_num a_num := a_num(1,2,3,4,5,6,7,8,9,10);
begin
	for i in b_num.first..b_num.last loop
		if mod(b_num(i),2)=1 then
			dbms_output.put_line('홀수');
		else
			dbms_output.put_line('짝수');
		end if;
	end loop;
end;
/

x<-c(1:10)
for (i in x){if(i%%2==1){print('홀수')}else{print('짝수')}}
ifelse(x%%2==1,'홀수','짝수')

[문제107] mysentence 이름의 벡터 변수에 'Well begun is half done' 이 값을 입력한 후 공백문자를 기준으로 분리해서 word 변수에 입력하세요. 
	  word 변수에 타입을 체크한 후 word 변수에 입력된 값의 수를 출력하세요.

mysentence<-'Well begun is half done'
word<-strsplit(mysentence,split=" ")
str(word) # list 이므로 unlist 하여 값을 구한다.
List of 1
 $ : chr [1:5] "Well" "begun" "is" "half" ...

length(unlist(word))

sapply(word,length)

[문제108] 문제107에서 만든 word변수에 있는 값을  리스트 변수 letters에 하나씩 저장하세요.

letters<-list()
for (i in 1:length(unlist(word))){letters<-append(letters,unlist(word)[i],after=i)}
for (i in 1:length(unlist(word))){letters<-append(letters,word[[1]][i],after=i)}

letters<-list(NA)
for (i in 1:length(unlist(word))){letters[[i]]<-word[[1]][i]}

[문제109] 문제108에서 생성한 letters 변수에 있는 값을 myword변수에 하나의 문장으로 넣어 주세요.

> myword
[1] "Well begun is half done"
myword<-c(NULL)
for(i in 1:length(letters)){myword <- paste(c(myword,letters[[i]][1]),collapse=' ')}

collapse - 결과물에서 분리해주는 paste 옵션 

[문제110] hap함수에 인자값을 입력하게 되면 1부터해서 입력숫자 까지 누적합을 구하세요

hap <- function(x){res<-0 
                  for(i in 1:x){
                                res<-res+i}
                  return(res)}

[문제111] 인수값에 따라 합을 구하세요

hap(1,2)
hap(1,2,3)
hap(10,20,30,40)

hap<-function(...){res<-0
		   x<-c(...)
		   for (i in x){
				res<-res+i
				}
	           return(res)
		   }
		
[문제112] x변수에 1:5 까지 입력되어 있다 아래 화면 처럼 출력하세요.

<화면결과>

[[1]]
[1] "홀수"

[[2]]
[1] "짝수"

[[3]]
[1] "홀수"

[[4]]
[1] "짝수"

[[5]]
[1] "홀수"

x<-1:5

a<-function(x){y<-list()
               for (i in 1:length(x)){
                                      if(x[i]%%2==1){
                                                      y[i]<-'홀수'
                                      }
                                      else{
                                              y[i]<-'짝수'
                                      }
                                      }
      return(y)} 
a(x)

sapply(x,a)

as.list(ifelse(x%%2==0,"짝수","홀수"))

lapply(x,function(x){ifelse(x%%2==0,"짝수","홀수")}) -- 함수를 적용하는 방법

[문제113] 사원 번호를 입력 값으로 받아서 사원의 LAST_NAME, SALARY를 출력하는 함수를 생성하세요.

create or replace package emp_pkg
is
	function find(p_id in number)
	return number;
	
end emp_pkg;
/

create or replace package body emp_pkg
is
	function find(p_id in number)
	return number
	is
		type v_tab is record(name varchar2(50), sal number);
		b_tab v_tab;
	begin
		select last_name,salary
		into b_tab
		from employees
		where employee_id=p_id;

		dbms_output.put_line('사원번호 : '||p_id);
		dbms_output.put_line('사원이름 : '||b_tab.name||', 사원번호 : '||b_tab.sal); 

	end find;
end emp_pkg;
/	 


> find(100)
   LAST_NAME SALARY
10      King  24000

find<-function(x){
		 	return (emp[emp$EMPLOYEE_ID==x,c('LAST_NAME','SALARY')])
		 }

[문제114] 20번 부서에 소속되어 있는 사원의 LAST_NAME,SALARY,JOB_ID, DEPARTMENT_NAME을 출력해 주세요.

emp_20<-emp[emp$DEPARTMENT_ID==20,]
merge(emp_20,dept,by='DEPARTMENT_ID')[,c('LAST_NAME','SALARY','JOB_ID', 'DEPARTMENT_NAME')]

select e.last_name, e.salary, e.job_id, d.department_name
from employees e, departments d
where d.department_id=e.department_id
and e.department_id=20;

select last_name,salary,job_id,department_name
from employees join departments
using(department_id)
where department_id=20;

  LAST_NAME SALARY JOB_ID DEPARTMENT_NAME
1 Hartstein  13000 MK_MAN       Marketing
2       Fay   6000 MK_REP       Marketing

[문제115] salary가 3000 이상이고 job_id는 ST_CLERK인 사원들의 employee_id, salary, job_id, department_id,department_name을 출력하세요.

y<-emp[emp$SALARY>=3000 & emp$JOB_ID=='ST_CLERK',]
merge(y,dept,by='DEPARTMENT_ID')[,c('EMPLOYEE_ID','JOB_ID','DEPARTMENT_ID','DEPARTMENT_NAME')]

select e.employee_id,e.salary,e.department_id,d.department_name
from employees e, departments d
where e.department_id=d.department_id
and e.salary>=3000
and e.job_id='ST_CLERK';

select employee_id, salary, job_id, department_id,department_name
from employees join departments
using(department_id)
where salary>=3000
and job_id='ST_CLERK';

[문제116]  커미션이 NA 인 사원들의 last_name, commission_pct, department_id, department_name을 출력하세요.

x<-emp[is.na(emp$COMMISSION_PCT),c('LAST_NAME','COMMISSION_PCT','DEPARTMENT_ID')]
merge(x,dept,by='DEPARTMENT_ID')[,c('LAST_NAME','COMMISSION_PCT','DEPARTMENT_ID','DEPARTMENT_NAME')]

a<-merge(emp,dept,by='DEPARTMENT_ID')[,c('LAST_NAME','COMMISSION_PCT','DEPARTMENT_ID','DEPARTMENT_NAME')]
a[is.na(a$COMMISSION_PCT),]

select e.last_name, e.commission_pct, e.department_id, d.department_name
from employees e, departments d
where e.department_id=d.department_id
and e.commission_pct is null;

[문제117]  커미션이 NA가 아닌 사원들의 last_name, commission_pct,department_id, department_name을 출력하세요.

x<-emp[!is.na(emp$COMMISSION_PCT),c('LAST_NAME','COMMISSION_PCT','DEPARTMENT_ID')]
merge(x,dept,by='DEPARTMENT_ID')[,c('LAST_NAME','COMMISSION_PCT','DEPARTMENT_ID','DEPARTMENT_NAME')]

a<-merge(emp,dept,by='DEPARTMENT_ID')[,c('LAST_NAME','COMMISSION_PCT','DEPARTMENT_ID','DEPARTMENT_NAME')]
a[!is.na(a$COMMISSION_PCT),]

select e.last_name, e.commission_pct, e.department_id, d.department_name
from employees e, departments d
where e.department_id=d.department_id
and e.commission_pct is not null;

[문제118] 커미션이 NA가 아닌 사원들의 last_name, commission_pct, department_id, department_name을 출력하세요.
	  단 department_id가 NA인 사원도 출력해주세요.

x<-emp[!is.na(emp$COMMISSION_PCT),c('LAST_NAME','COMMISSION_PCT','DEPARTMENT_ID')]
merge(x,dept,by='DEPARTMENT_ID',all.x=TRUE)[,c('LAST_NAME','COMMISSION_PCT','DEPARTMENT_ID','DEPARTMENT_NAME')]

a<-merge(emp,dept,by='DEPARTMENT_ID',all=T)[,c('LAST_NAME','COMMISSION_PCT','DEPARTMENT_ID','DEPARTMENT_NAME')]
a
a[!is.na(a$COMMISSION_PCT),]

select e.last_name, e.commission_pct, e.department_id, d.department_name
from employees e, departments d
where e.department_id=d.department_id(+)
and e.commission_pct is not null;

[문제119] 사원의 last_name, 관리자 last_name을 출력해주세요. 관리자가 없는 사원도 출력해주세요.

a<-emp[,c('LAST_NAME','EMPLOYEE_ID','MANAGER_ID')]
b<-emp[,c('LAST_NAME','EMPLOYEE_ID')]

merge(a,b,by.x='MANAGER_ID',by.y='EMPLOYEE_ID',all.x=T)[,c('LAST_NAME.x','LAST_NAME.y')]

merge(a,b,all.x=T)[,c('LAST_NAME.x','LAST_NAME.y')]

select e1.last_name,e2.last_name
from employees e1, employees e2
where e1.manager_id=e2.employee_id;

[문제120] 부서이름별 총액 급여를 출력하세요. -- 부서이름별 -> department_id 로해서 sum을 하면 employees 와 departments 해서 연결해서 하면 값이나온다. 

aggregate(계산될 컬럼~분할해야할 기준컬럼, 데이터, 함수)

a<-emp[,c('SALARY','DEPARTMENT_ID')]
b<-dept[,c('DEPARTMENT_ID','DEPARTMENT_NAME')]
c<-merge(a,b)
c1<-merge(a,b,by='DEPARTMENT_ID')
aggregate(SALARY~DEPARTMENT_NAME,c,sum)
aggregate(SALARY~DEPARTMENT_NAME,c1,sum)

d<-aggregate(SALARY~DEPARTMENT_ID,emp,sum)
names(d)<-c('DEPARTMENT_ID','SUM_SAL')
e<-dept[,c('DEPARTMENT_ID','DEPARTMENT_NAME')]
merge(d,e,by='DEPARTMENT_ID')[,c('DEPARTMENT_ID','SUM_SAL')]

select d.department_name, avg(e.salary)
from employees e, departments d
where e.department_id=d.department_id
group by d.department_name;

select d.department_id,e.sumsal
from (select department_id, sum(salary) sumsal
      from employees
      group by department_id) e, departments d
group by d.department_name;

[문제121] 부서이름별 소속사원들의 인원수를 출력하세요.

emp<-read.csv('emp.csv',header = TRUE,stringsAsFactors = FALSE)
dept<-read.csv('dept.csv',header = TRUE,stringsAsFactors = FALSE)

a<-aggregate(EMPLOYEE_ID~DEPARTMENT_ID,emp,length)
a
names(a)<-c('DEPARTMENT_ID','COUNT')
merge(a,dept,by.x='DEPARTMENT_ID',by.y='DEPARTMENT_ID')[,c('DEPARTMENT_NAME','COUNT')])

select d.department_name,e.cn
from (select department_id, count(*) cn
      from employees
      group by department_id)e, departments d
where e.department_id=d.department_id;

select d.department_name,count(*)
from employees e, departments d
where e.department_id=d.department_id
group by d.department_name;

[문제122] 최고 급여를 받는 사원의 이름, 급여, 부서코드, 부서이름를 출력하세요.

a<-emp[emp$SALARY==max(emp$SALARY),c('LAST_NAME','SALARY','DEPARTMENT_ID')]
a
b<-dept[,c('DEPARTMENT_ID','DEPARTMENT_NAME')]
merge(a,b)

select e.last_name,e.salary,d.department_id,d.department_name
from employees e, departments d
where e.department_id=d.department_id
and e.salary =(select max(salary)
               from employees);

[문제123] 부서이름,직업별 급여의 총액을 구하세요.

x<-aggregate(SALARY~DEPARTMENT_ID+JOB_ID,emp,sum)
y<-dept[,c('DEPARTMENT_ID','DEPARTMENT_NAME')]
merge(x,y)[,c('DEPARTMENT_NAME','JOB_ID','SALARY')]

a<-merge(emp,dept,by='DEPARTMENT_ID')
b<-aggregate(SALARY~DEPARTMENT_NAME+JOB_ID,a,sum)

select d.department_name,e.job_id,sum(e.salary)
from employees e, departments d
where e.department_id=d.department_id
group by d.department_name,e.job_id;

[문제124] loc.csv 파일을 loc 변수로 로드하세요.
	 Toronto 지역에 근무하는 사원들의 LAST_NAME,SALARY,DEPARTMENT_ID,DEPARTMENT_NAME,STREET_ADDRESS 정보를 출력하세요.

loc<-read.csv("loc.csv",header=T,stringsAsFactors = FALSE)
a<-loc[loc$CITY=='Toronto',c('STREET_ADDRESS','LOCATION_ID')]
b<-merge(emp,dept,by='DEPARTMENT_ID')
c<-merge(a,b,by='LOCATION_ID')[,c('LAST_NAME','SALARY','DEPARTMENT_ID','DEPARTMENT_NAME','STREET_ADDRESS')]

select e.last_name,e.salary,e.department_id,d.department_name,l.street_address
from employees e, departments d, locations l
where e.department_id=d.department_id
and d.location_id=l.location_id
and l.city='Toronto';

[문제125] 아래 화면의 결과처럼 출력해주세요.


           부서이름 부서별급여
     Administration       4400
          Marketing      19000
         Purchasing      24900
    Human Resources       6500
           Shipping     156400
                 IT      28800
   Public Relations      10000
              Sales     304500
          Executive      63040
            Finance      51608
         Accounting      20308
          소속부서X       7000
         사원총급여     696456

x<-aggregate(SALARY~DEPARTMENT_ID,emp,sum)
y<-merge(x,dept,by='DEPARTMENT_ID')[,c('DEPARTMENT_NAME','SALARY')]
z<-data.frame(DEPARTMENT_NAME=c('소속부서X'),SALARY=emp[is.na(emp$DEPARTMENT_ID),'SALARY'])
q<-data.frame(DEPARTMENT_NAME=c('사원총급여'),SALARY=sum(emp$SALARY))
hap<-rbind(y,z,q)
names(hap)<-c('부서이름','부서별급여')
hap

select nvl(d.department_name,'소속부서x') as "부서이름" ,sum(e.salary) as "부서별급여"
from employees e, departments d
where e.department_id=d.department_id(+)
group by d.department_name
union all
select '사원총급여',sum(salary)
from employees order by 1;

[문제126] 30번 부서 사원이면서 급여는 3000이상 받는 사원들의 last_name, hire_date, salary, job_id, department_id 출력해주세요.
          단 subset 함수를 이용하세요.

a<-subset(emp,DEPARTMENT_ID==30&SALARY>=3000,select=c(LAST_NAME,HIRE_DATE,SALARY,JOB_ID,DEPARTMENT_ID))

select last_name,hire_date,salary,job_id,department_id
from employees
where department_id=30 
and salary>=3000;

[문제127] 입사한 날짜가 2002,2003년도에 입사한 사원들의 last_name, hire_date, salary, job_id, department_id 출력해주세요.
          단 subset 함수를 이용하세요.

b<-subset(emp,substr(emp$HIRE_DATE,1,4)=='2002' | substr(emp$HIRE_DATE,1,4)=='2003',select=c(LAST_NAME,HIRE_DATE,SALARY,JOB_ID,DEPARTMENT_ID))

emp$HIRE_DATE<-as.Date(as.character(emp$HIRE_DATE),format='%Y%m%d')
format(emp$HIRE_DATE) %in% c('2002',2003')

select last_name,hire_date,salary,job_id,department_id
from employees
where to_char(hire_date,'yyyy')='2002' 
or to_char(hire_date,'yyyy')='2003';

[문제128] 문제126번 결과하고 문제127결과를 하나로 합쳐 주세요.

c<-rbind(a,b)

select last_name,hire_date,salary,job_id,department_id
from employees
where department_id=30 
and salary>=3000
union all
select last_name,hire_date,salary,job_id,department_id
from employees
where to_char(hire_date,'yyyy')='2002' 
or to_char(hire_date,'yyyy')='2003';

[문제129] 문제126번 결과하고 문제127결과 하나로 합치되 중복되는 데이터는 제거해주세요.

unique(c)

merge(a,b,all.y=T)

library(doBy)
orderBy(~LAST_NAME,unique(rbind(a,b)))

select last_name,hire_date,salary,job_id,department_id
from employees
where department_id=30 
and salary>=3000
union
select last_name,hire_date,salary,job_id,department_id
from employees
where to_char(hire_date,'yyyy')='2002' 
or to_char(hire_date,'yyyy')='2003';


select last_name,hire_date,salary,job_id,department_id
from employees
where to_char(hire_date,'yyyy')='2002' 
or to_char(hire_date,'yyyy')='2003'
union all
select last_name,hire_date,salary,job_id,department_id
from employees
where department_id=30 
and salary>=3000
and not exists (select 'x'
              	from employees
                where to_char(hire_date,'yyyy')='2002' 
                or to_char(hire_date,'yyyy')='2003');

[문제130] 150번 사원의 급여보다 더 많은 급여를 받는 사원들의 last_name, salary 를 출력하세요.

★ 만약 subset으로 해서 비교를 하게 되면 subset은 data.frame이기 때문에 비교하려면 unlist를 사용해서 푼다.

subset(emp,SALARY>=emp[emp$EMPLOYEE_ID==150,'SALARY'],select=c(LAST_NAME,SALARY))

select last_name, salary
from employees
where salary >= (select salary
		from employees
		where employee_id=150);

[문제131] 사원 테이블에서 가장 많은 급여를 받는 사원의 이름과 월급을 출력하세요.

subset(emp,SALARY==max(emp$SALARY),select=c(LAST_NAME,SALARY))

select last_name, salary
from employees
where salary = (select max(salary)
		 from employees);
		  


[문제132] job_id가  SA_REP인 사원의 최대급여 이상 받는 사원들의 last_name,salary,job_id를 출력하세요.

subset(emp,SALARY>=max(emp[emp$JOB_ID=='SA_REP','SALARY']),select=c(LAST_NAME,SALARY,JOB_ID))

select last_name,salary,job_id
from employees
where salary >= (select max(salary)
		 from employees
		 where job_id='SA_REP');

[문제133]  KING 에게 보고하는 사원들의 last_name, salary를 출력하세요.

subset(emp,MANAGER_ID %in% emp[toupper(emp$LAST_NAME)=='KING','EMPLOYEE_ID'],select=c(LAST_NAME,SALARY))

select last_name, salary
from employees
where manager_id in (select employee_id
		     from employees
		     where upper(last_name)='KING');

[문제134] 자신의 관리자 보다 더 많은 급여를 받는 사원이름, 사원급여, 관리자이름, 관리자급여를 출력하세요.

library(sqldf)

x<-sqldf("select e2.last_name,e2.salary,e1.last_name,e1.salary 
	     from emp e1 join emp e2
       on e1.employee_id=e2.manager_id
       where e2.salary > e1.salary")

names(x)<-c("사원이름","사원급여","관리자이름","관리자급여")
x

select e2.last_name as "사원이름",e2.salary as "사원급여",e1.last_name as "관리자이름",e1.salary as "관리자급여"
from employees e1, employees e2
where e1.employee_id=e2.manager_id
and e2.salary > e1.salary;

[문제135] 자신의 부서 평균 급여보다 많이 받는 사원들의 정보를 출력하세요.


sqldf("select *
       from emp e1
       where salary > (select avg(salary)
                       from emp e2
                       where e1.department_id=e2.department_id)")

sqldf("select e2.*
      from (select department_id, avg(salary) avgsal
            from emp
            group by department_id) e1, emp e2
      where e1.department_id=e2.department_id
      and e2.salary>e1.avgsal")


select *
from employees e1
where salary > (select avg(salary)
                from employees e2
                where e1.department_id=e2.department_id);


select e2.*
from (select department_id, avg(salary) avgsal
      from employees
      group by department_id) e1, employees e2
where e1.department_id=e2.department_id
and e2.salary>e1.avgsal;

[문제136] fruits_sales.csv file 읽어 들인 후 과일 이름별 판매량, 판매합계를 구하세요.(tapply를 이용하세요)

       qty price
apple   44 66000
banana  31 70000
berry   52 95100
orange  21 83000

fru<-read.csv("fruits_sales.csv",header = T,stringsAsFactors = FALSE)
fru

a<-(tapply(fru$qty,fru$name,sum)) - 여기서 이름은 rowname 이다. / array 형식이기 때문에
b<-(tapply(fru$price,fru$name,sum))
c<-cbind(a,b)
c
colnames(c)<-c('qty','price')
c

c<-cbind(qty=a,price=b) - 바로 이름을 정해주는 것도 가능하다.

[문제137] fruits_sales.csv file 읽어 들인 후 과일 이름별 판매량, 판매합계를 구하세요.(aggregate를 이용하세요)

       qty price
apple   44 66000
banana  31 70000
berry   52 95100
orange  21 83000

d<-aggregate(qty~name,fru,sum) - data.frame 형식이므로 merge로 하면 된다.
e<-aggregate(price~name,fru,sum)
f<-cbind(d,e)
f<-f[,-3]
f    

g<-merge(d,e)
names(g)[1]<-' '
g

[문제138] fruits_sales.csv file 읽어 들인 후 과일 이름별 판매량, 판매합계를 구하세요.(sqldf를 이용하세요)

       qty price
apple   44 66000
banana  31 70000
berry   52 95100
orange  21 83000

sqldf("select name,sum(qty) as qty,sum(price) as price from fru group by name")  


[문제139] fruits_sales.csv file 읽어 들인 후 년도별로 판매량 중에 가장 많은 판매를 한 년도를 출력해주세요.(tapply를 이용하세요)

a<-tapply(fru$qty,fru$year,sum) # 이름이 rowname으로 들어가기 때문에 max값이 위치한 값을 찾아서 찾는다.
rownames(a)[which(a==max(a))]

names(a[a==max(a)])

[문제140] fruits_sales.csv file 읽어 들인 후 년도별로 판매량 중에 가장 많은 판매를 한 년도를 출력해주세요.(aggregate를 이용하세요)

b<-aggregate(qty~year,fru,sum) 
c<-b[which(max(b[2])==b[2]),1] # 어차피 year가 1열에 있는 것을 알기 때문에
b[max(b[2])==b[2],1]

b[b$qty==max(b$qty),'year'] # 데이터 프레임이니 열 값을 직접해서 부를 수 있다.

[문제141] fruits_sales.csv file 읽어 들인 후 년도별로 판매량 중에 가장 많은 판매를 한 년도를 출력해주세요.(sqldf를 이용하세요)

sqldf("select year
       from (select year,max(a)
             from(select year, sum(qty) a
	          from fru
                  group by year))")

[문제142] fruits_sales.csv file 읽어 들인 후 과일 이름별 판매량, 판매합계를 구하세요.
	  ddply함수를 이용하세요.

library(plyr)

ddply(fru,'name',summarise,sum_qty=sum(qty),sum_price=sum(price))


[문제143] emp 데이터 프레임을 새로운 df 이름으로 복제하세요.
           df 데이터 프레임에  새로운 comm 컬럼을 생성하는데 COMMISSION_PCT 값을 기반으로 값을 입력하시고
           결측값은 기존 COMMISSION_PCT의 평균 값으로 입력해주세요.(단 mutate함수를 이용하세요)

library(dplyr)
df<-emp

df<-mutate(emp,comm=ifelse(is.na(COMMISSION_PCT),mean(COMMISSION_PCT,na.rm=TRUE),COMMISSION_PCT))

[문제144] 부서별 급여의 총액을 pie chart를 생성하세요.

library(plyr)
x<-ddply(emp,'DEPARTMENT_ID',summarise,sum_sal=sum(SALARY))

library(doBy)
x<-orderBy(~-sum_sal,x)
z<-c(1:length(x$DEPARTMENT_ID))
a<-x$DEPARTMENT_ID
b<-x$sum_sal
c<-paste(z,'위 총 급여: ',b,sep="")
d<-paste('부서번호 : ',a,sep="")
pie(b,labels=c,main='부서별 총 급여',col=rainbow(length(b)),clockwise=TRUE,init.angle=160)
legend(1,1,d,fill=rainbow(length(df$SALARY)))


df<-aggregate(SALARY~DEPARTMENT_ID,emp,sum)
label1<-paste(df$DEPARTMENT_ID,'부서',sep="")
label2<-paste(df$SALARY,'만원',sep="")
pie(df$SALARY,labels=label2,main="부서별 총액 급여",col=rainbow(length(df$SALARY)))

# 범례 표현

legend(1,1,label1,fill=rainbow(length(df$SALARY)))


[문제145] 성별 현황을 조사 자료를 이용하여 성별 인구 비율을 원형 차트로 만드세요.

성별 현황

구분	조사수
----	------
남자	226965
여자	241319

colors()
x<-data.frame("구분"=c('남자','여자'),"조사수"=c(226965,241319))
y<-x$조사수/sum(x$조사수)*100
z<-paste(round(y),'%',sep="")
pie(y,labels=z,main='성별 인구 비율',col=rainbow(length(x$조사수)),clockwise=TRUE)

pie(y,labels=z,main='성별 인구 비율',col=c('blue','red'),clockwise=TRUE)
legend("topright",legend=x$구분,cex=0.6,fill=c('blue','red'))

# legend 옵션 

lty - 점선
lwd - 실선
pch - 각 숫자마다 모양이 생김
bg - 배경색깔
box.lty - 범례 박스 점선
box.lwd - 범례 박스 실선 
pt.bg - 배경 포인트 컬러
cex - 글씨 크기
adj - 글씨 내리기 


- 3D 로 할 경우

library(plotrix)

pie3D(round(y),labels=z, explode=0.1,labelcex=1,start=2,main='성별 인구 비율',col=rainbow(length(x$조사수)))
legend(1,1,x$구분,fill=rainbow(length(x$조사수)))

# 범례를 만들지 않고 그래프 안에다가 글자를 넣는 방법

p<-pie3D(round(y),labels=z, explode=0.1,labelcex=1,start=2,main='성별 인구 비율',col=rainbow(length(x$조사수))shade=0.5)
pie3D.labels(p,labels=x$구분,labelrad=0.5, labelcex=0.7, labelcol="whitesmoke")

#pid3D 옵션 

start - 그래프를 움직인다. 
pie3D.labels - 그래프안에다 글자 넣기
labelrad= 위치 값 표현
labelcex= 글씨 크기 조절
labelcol= 색깔
shade - 명암



[문제146] 성별 현황을 조사 자료를 이용하여 성별 인구수를 막대그래프로 만드세요.

성별 현황

구분	조사수
----	------
남자	226965
여자	241319	


a<-barplot(height=x$조사수,names.arg=x$구분,horiz=FALSE,width=0.1,xlab='성별',main='성별 인구 수',col=rainbow(length(x$조사수)),axes=TRUE,ylim=c(0,292000))
b<-text(x=a,y=x$조사수,labels=x$조사수,pos=3)

# barplot   : 막대그래프 
# height    : 숫자값 변수들, 최대크기가 높이 / 막대크기를 나타내는 벡터(숫자형)
# width     : 막대의 넓이 / 막대너비
# names.arg : 각 막대그래프 이름 / 막대 아래 출력되는 이름
# col       : 막대 색상
# main      : 제목
# sub       : 부제목
# horiz     : TRUE(수평막대),FALSE(수직막대)
# xlab      : x축 이름
# ylab      : y축 이름 
# xlim      : x축의 크기 
# ylim      : y축의 크기
# axes	    : y축 제거

[문제147] 부서별 인원수 막대그래프를 생성하세요. 단 부서없는 사원들의 인원수도 포함하세요.

library(plyr)

a<-ddply(emp,'DEPARTMENT_ID',summarise,emp_cn=length(EMPLOYEE_ID))
a$DEPARTMENT_ID<-ifelse(is.na(a$DEPARTMENT_ID),'NULL',a$DEPARTMENT_ID)
b<-barplot(height=a$emp_cn,names.arg=a$DEPARTMENT_ID,horiz=FALSE,xlab='부서번호',col=rainbow(length(a$DEPARTMENT_ID)),axes=TRUE,ylim=c(0,50),ylab='인원수',main='부서별 인원수')
c<-text(x=b,y=a$emp_cn,labels=a$emp_cn,pos=3)


# 인원수 대로 오름차순 

library(doBy)

d<-ddply(emp,'DEPARTMENT_ID',summarise,emp_cn=length(EMPLOYEE_ID))
d<-orderBy(~-emp_cn,d)
d$DEPARTMENT_ID<-ifelse(is.na(d$DEPARTMENT_ID),'NULL',d$DEPARTMENT_ID)
e<-barplot(height=d$emp_cn,names.arg=d$DEPARTMENT_ID,horiz=FALSE,xlab='부서번호',col=rainbow(length(d$DEPARTMENT_ID)),axes=TRUE,ylim=c(0,50),ylab='인원수',main='부서별 인원수')
f<-text(x=e,y=d$emp_cn,labels=d$emp_cn,pos=3)

# 다른 방법

dept_cn<-aggregate(EMPLOYEE_ID~ifelse(is.na(DEPARTMENT_ID),'부서없음',DEPARTMENT_ID),emp,length)
names(dept_cn)<-c('dept_id','cn')

bp<-barplot(dept_cn$cn,names.arg=dept_cn$dept_id,main='부서별 인원수',xlab='부서',col=rainbow(length(dept_cn$dept_id)),cex.name=0.7,axes=FALSE)
label<-paste(dept_cn$cn,'명')
text(x=bp,y=dept_cn$cn,labels=label,cex=0.9,pos=3)

[문제148] 부서 이름별 급여 총액에 대해서 막대그래프를 생성하세요.단 부서없는 사원들의 인원수도 포함하세요.

x<-dept[,c('DEPARTMENT_ID','DEPARTMENT_NAME')]
y<-emp[,c('DEPARTMENT_ID','SALARY')]
z<-merge(x,y,by='DEPARTMENT_ID',all.y=TRUE)[,c('DEPARTMENT_NAME','SALARY')]
q<-ddply(z,'DEPARTMENT_NAME',summarise,sum_sal=sum(SALARY))

w<-barplot(height=q$sum_sal,main='부서 이름별 급여 총액',names.arg=q$DEPARTMENT_NAME,xlab='부서이름',col=rainbow(length(q$sum_sal)),ylim=c(0,320000),las=2)

# las - y축을 가로로 바꿔주는 값, x축은 세로

text(x=w,y=q$sum_sal,labels=q$sum_sal,pos=1,cex=0.5)
text(x=w[which(q$sum_sal==max(q$sum_sal)),1],y=max(q$sum_sal),labels='최고급여',pos=3,cex=1,col='red')
text(x=w[which(is.na(q$DEPARTMENT_NAME)),1],y=q[which(is.na(q$DEPARTMENT_NAME)),'sum_sal'],labels='부서(x)',pos=3,cex=1,col='red')

[문제149] fruits_sales.csv을 읽어 들인 후 년도별, 과일이름별 판매량을  그룹형 막대 그래프로 만드세요.

# ddply

a<-ddply(fru,c('year','name'),summarise,sum_qty=sum(qty))
b<-rbind(a$year,a$sum_qty)
c<-unique(a$name)

d<-barplot(b[2,],main='연도별, 과일이름별 판매량',beside=T,names.arg=b[1,],col=rainbow(4),legend.text=c,axes=FALSE,ylim=c(0,25))
label<-paste(labels=b[2,],'개',sep="")
text(x=d,y=b[2,],labels=label,pos=3)

# tapply

aa<-tapply(fru$qty,list(fru$year,fru$name),sum)

bb<-barplot(aa,main='연도별 과일이름별 판매량', beside=T, col=rainbow(NROW(aa)),names.arg=rownames(aa),axes=FALSE,ylim=c(0,25),legend.text=colnames(aa))
text(x=bb,y=aa,labels=paste(aa,'개',sep=""),pos=3,cex=0.8)

legend

# title - 범례 제목
# pch - 범례 모양 바꾸기

# barlabels - library(plotrix) 에 있는 method로 level을 표현할 수 있는 method 이다.
matrix - 순서대로 값을 나오게 한다.
border - 선 테두리
srt - 각도
bg - 배경색 지정

[문제150] exam.csv file에는 학생들의 시험점수가 있습니다. 학생들의 SQL 점수를 막대그래프로 출력해주세요.

exam<-read.csv('c:/data/exam.csv',header = T,stringsAsFactors = FALSE)

aa<-exam[exam$subject=='SQL',c('name','grade')]
a<-orderBy(~-grade,aa)
b<-barplot(height=a$grade,names.arg=a$name,main='SQL 시험점수',col=rainbow(length(a$name)),ylim=c(0,100),xlab='학생이름',axes=FALSE,width=0.3,legend.text=a$name,las=2)
c<-paste(a$grade,'점',sep="")
text(x=b,y=a$grade,labels=c,pos=3,cex=0.7)

[문제151] exam.csv file에는 학생들의 시험점수가 있습니다. 학생들의 R 점수를 막대그래프로 출력해주세요.

dd<-exam[exam$subject=='R',c('name','grade')]
d<-orderBy(~-grade,dd)
e<-barplot(height=d$grade,names.arg=d$name,main='R 시험점수',col=rainbow(length(d$name)),ylim=c(0,100),xlab='학생이름',axes=FALSE,width=0.3,legend.text=d$name,las=2)
f<-paste(d$grade,'점',sep="")
text(x=e,y=d$grade,labels=f,pos=3,cex=0.7)

[문제152] exam.csv file에는 학생들의 시험점수가 있습니다. 학생들의 PYTHON 점수를 막대그래프로 출력해주세요.

gg<-exam[exam$subject=='PYTHON',c('name','grade')]
g<-orderBy(~-grade,gg)
i<-barplot(height=g$grade,names.arg=g$name,main='PYTHON 시험점수',col=rainbow(length(g$name)),ylim=c(0,100),xlab='학생이름',axes=FALSE,width=0.3,legend.text=d$name,las=2)
j<-paste(g$grade,'점',sep="")
text(x=i,y=g$grade,labels=j,pos=3,cex=0.7)


[문제153] exam.csv file에는 학생들의 시험점수가 있습니다. 학생들의 과목 총 점수를 막대그래프로 출력하세요.

library(plyr)

ss<-aa$grade+dd$grade+gg$grade
qq<-data.frame(name=aa$name,grade=ss)
x<-orderBy(~-grade,qq)
y<-barplot(height=x$grade,names.arg=x$name,main='학생들의 과목 총 점수',col=rainbow(length(x$name)),ylim=c(0,320),xlab='학생이름',axes=FALSE,width=0.3,legend.text=x$name,las=2)
z<-paste(x$grade,'점',sep="")
text(x=y,y=x$grade,labels=z,pos=3,cex=0.7)


library(sqldf)
zz<-sqldf('select name,sum(grade) as sum_grade from exam group by name')
xx<-orderBy(~-sum_grade,zz)
yy<-barplot(height=xx$sum_grade,names.arg=xx$name,main='학생들의 과목 총 점수',col=rainbow(length(xx$name)),ylim=c(0,320),xlab='학생이름',axes=FALSE,width=0.3,legend.text=xx$name,las=2)
vv<-paste(xx$sum_grade,'점',sep="")
text(x=yy,y=xx$sum_grade,labels=vv,pos=3,cex=0.7)


# graphics.off() -- 화면의 그래프를 clear 해주는 함수 / 아예 초기화가 된다 par(mfrow=c(1,1))

par(mfrow=c(1,1)) -- 화면에 그래프를 몇개 표현할지를 해주는 함수 par(mfrow=c(행,열))
par(mfrow=c(2,2))

# box() -- 그래프에 box가 그려지는 함수

aggregate(grade~name,exam,sum)

[문제154] 학생들의 이름을 기준으로 과목점수를 스택형 막대그래프로 생성하세요.

graphics.off()
par(mfrow=c(2,1))

x<-tapply(exam$grade,list(exam$subject,exam$name),sum)
y<-barplot(x,col=rainbow(length(rownames(x))),ylim=c(0,320),main='총 과목점수',las=2)
legend("topright",rownames(x),fill=rainbow(length(rownames(x))),title='과목',cex=0.5,title.col='red',pch=10,pt.cex=1)
box()
text(x=y,y=colSums(x),labels=paste(colSums(x),'점',sep=""),pos=3,cex=0.5)
barlabels(y,x,bg=rainbow(length(rownames(x))),border=rainbow(length(rownames(x))),cex=0.5)

barlabels(y,zzz,x,bg=rainbow(length(rownames(x))),border=rainbow(length(rownames(x))),cex=0.5)

pch - 모양
pt.cex - 글자 굵기

# balabels(그래프,위치,값) - library(plotrix)

zzz<-matrix(c(x[1,],colSums(x[1:2,]),colSums(x)),nrow=3,byrow=TRUE)


[문제155] 학생들의 이름을 기준으로 과목점수를 그룹형 막대그래프로 생성하세요.

yy<-barplot(x,col=rainbow(length(rownames(x))),ylim=c(0,120),main='총 과목점수',las=2,beside=T)
legend("topright",rownames(x),fill=rainbow(length(rownames(x))),title='과목',cex=0.5,title.col='red')
box()
text(x=yy,y=x,labels=paste(x,'점',sep=""),pos=3,cex=0.5)

# abline -- 그래프에 선을 나타내는 함수
예)
abline(h=seq(100,300,100),col='red',lty=2)

h- 어디다 줄을 만들 것인가
col- 색깔
lty - 선의 모양 

[문제156] 창업건수.csv 파일에 데이터 중에 년도별 치킨집 창업 건수를 막대그래프로 생성하세요.

cre<-read.csv('c:/data/창업건수.csv',header = T,stringsAsFactors = FALSE)

a<-cre[,c('년도','치킨집')]

b<-barplot(height=a$치킨집,names.arg=a$년도,col=rainbow(length(a$년도)),main='연도별 치킨집 창업건수',ylim=c(0,1300))
legend("topright",a$년도,fill=rainbow(length(a$년도)),title='년도',title.col='red',pch=5)
box()
text(x=b,y=a$치킨집,labels=paste(a$치킨집,'건',sep=""),pos=3,cex=0.7)

[문제157] 년도별 치킨집 창업, 폐업 건수를 그룹형 막대그래프로 생성하세요.

b<-fail[,c('년도','치킨집')]
c<-rbind(a$치킨집,b$치킨집)
colnames(c)<-a$년도
rownames(c)<-c('창업수','폐업수')

d<-barplot(c,beside=T,names.arg=colnames(c),ylim=c(0,4000),main='연간 치킨집 창업,폐업 건수',col=c('red','blue'))
legend("topright",rownames(c),fill=c('red','blue'))
text(x=d,y=c,labels=c,pos=3,cex=0.7)

[문제158] 2014 년도 업종별 창업 비율을 원형 그래프로 생성하세요.

x<-cre[cre$년도==2014,]
x<-x[,!colnames(x) %in% c('년도')]
x<-x[order(x,decreasing = TRUE)]
y<-pie(round(unlist(x)/sum(x)*100),labels=paste(round(unlist(x)/sum(x)*100),'%',sep=""),col=rainbow(length(x)),main='2014년도 업종 별 창업 비율',clockwise=TRUE,init.angle=270)
legend("topright",colnames(x),fill=rainbow(length(x)))

# 3D로 만들기

library(plotrix)
x<-cre[cre$년도==2014,]
x<-x[,!colnames(x) %in% c('년도')]
x<-x[order(x,decreasing = TRUE)]
y<-pie3D(round(unlist(x)/sum(x)*100),labels=paste(round(unlist(x)/sum(x)*100),'%',sep=""),col=rainbow(length(x)),main='2014년도 업종 별 창업 비율',explode=0.1,start=2)
pie3D.labels(y,labels=colnames(x),labelrad=0.6,labelcol='black',labelcex=0.7)

#pid3D 옵션 

start - 그래프를 움직인다. 
pie3D.labels - 그래프안에다 글자 넣기
labelrad= 위치 값 표현
labelcex= 글씨 크기 조절
labelcol= 색깔
shade - 명암


[문제159] 년도를 입력하면 해당 년도의 원형 그래프 생성할 수 있는 함수를 생성하세요.

show_pie(2006)

show_pie<-function(x){ y<-c()
			if (is.numeric(which(2014==cre$년도))==TRUE){
					y<-cre[x==cre$년도,]
					y<-y[,!colnames(y) %in% c('년도')]
					y<-y[order(y,decreasing = TRUE)]
					z<-pie(round(unlist(y)/sum(y)*100),labels=paste(round(unlist(y)/sum(y)*100),'%',sep=""),col=rainbow(length(y)),main=paste(x,'년도 업종 별 창업 					   비율',sep=""),clockwise=TRUE,init.angle=270)
					legend("topright",colnames(y),fill=rainbow(length(y))) 
		     			}
		     }

# paste 옵션 : \n 다음줄로 떨어뜨린다. 단, 그래프 안에서 쓰는 paste에서만 가능, 그냥 R에서 쓰고싶다면 cat을 사용해야한다.


[문제160] 한 주간 영업 판매량을 막대그래프를 생성하데 막대그래프의 색상은 판매량에 따라 다르게 해야 합니다.
          판매량이 200 이상이면 red, 199 ~ 150 이면 yellow, 149 ~ 100 이면 blue, 99 ~ 50 pink, 49 ~ black색으로 출력하세요.

       월요일 : 70
       화요일 : 151
       수요일 : 210
       목요일 : 180
       금요일 : 250
       토요일 : 300
       일요일 : 40
       

x<-data.frame(day=c('월요일','화요일','수요일','목요일','금요일','토요일','일요일'),qty=c(70,151,210,180,250,300,40))

colors<-function(x){
			ifelse(x>=200,'red',ifelse(x>=150,'yellow',ifelse(x>=100,'blue',ifelse(x>=50,'pink','black'))))
		  }

y<-barplot(x$qty,main='판매량',names.arg=x$day,axes=FALSE,ylim=c(0,450),col=colors(x$qty),width=0.5)
text(x=y,y=x$qty,labels=x$qty,pos=3,cex=0.7)
z<-c('200개 이상','150개 이상 200개 미만','100개 이상 150개 미만','50개이상 100개 미만','50개 미만')
legend("topright",z,fill=c('red','yellow','blue','pink','black'),cex=0.7)

[문제161] itwill hotel 투수객 조사를 통해 고객들의 평가에 대한 정보는  survey.csv에 저장 되어 있습니다.
파일 내용을 통해서 호텔에 대한 고객들의 반응을 그래프로 생성하세요.


survey<-read.csv('c:/data/survey.csv',header=FALSE)
x<-as.vector(unlist(survey))
y<-unique(x)
z<-c()
for(i in 1:length(x)){z[i]<-length(x[(x %in% y[i])])}
z<-z[1:5]

xx<-pie(round(z/sum(z)*100),labels=paste(z/sum(z)*100,'%',sep=""),main='itwill hotel 투숙객 만족도',col=rainbow(length(z)))
legend("topright",y,fill=rainbow(length(z)))

yy<-barplot(height=z,names.arg=y,col=rainbow(length(x)),main='itwill hotel 투숙객 만족도',ylim=c(0,15),xlab='만족도',axes=FALSE)
text(x=yy,y=z,labels=z,pos=3)

# 오름차순 방법

aa<-read.csv('c:/data/survey.csv',header=FALSE)
aa<-as.vector(unlist(aa))
bb<-c()
for(i in 1:length(aa)){ifelse(aa[i]=='매우좋음',bb[i]<-1,ifelse(aa[i]=='좋음',bb[i]<-2,ifelse(aa[i]=='보통',bb[i]<-3,ifelse(aa[i]=='나쁨',bb[i]<-4,bb[i]<-5))))} 
cc<-sort(bb)
dd<-unique(names(cc))
a<-0
b<-0
c<-0
d<-0
e<-0
for(i in 1:length(aa)){ifelse(aa[i]=='매우좋음',a<-a+1,ifelse(aa[i]=='좋음',b<-b+1,ifelse(aa[i]=='보통',c<-c+1,ifelse(aa[i]=='나쁨',d<-d+1,e<-e+1))))} 
f<-c(a,b,c,d,e)
end1<-barplot(height=f,names.arg=dd,col=rainbow(length(f)),main='itwill hotel 투숙객 만족도',ylim=c(0,15),xlab='만족도',axes=FALSE)
end2<-text(x=end1,y=f,labels=paste(f,'명',sep=""),pos=3)

[문제162] itwill hotel 투수객 조사를 통해 고객들의 평가에 대한 정보는  survey.csv에 저장 되어 있습니다.
파일 내용을 통해서 호텔에 대한 고객들의 반응을 그래프로 생성하세요.(table함수를 이용해서 해결해주세요)

survey<-read.csv('c:/data/survey.csv',header=FALSE)
survey<-t(survey)

a<-factor(survey,levels=c("매우좋음","좋음","보통","나쁨","매우나쁨"))

b<-xtabs(~a)
b<-table(a)

c<-barplot(b,col=rainbow(length(b)),xlab='만족도',ylim=c(0,13),main='itwill hotel 투숙객 만족도 평가')
text(x=c,y=b,labels=b,pos=3)

d<-prop.table(b)*100
e<-pie(d,col=rainbow(length(d)),labels=paste(d,'%',sep=""),main='itwill hotel 투숙객 만족도 평가')
legend("topright",names(d),fill=rainbow(length(d)))


[문제163] 1군전염병발병현환_년도별.csv 에 데이터를 가지고 그래프를 생성하세요.

ff<-read.csv('1군전염병발병현황_년도별.csv',header=TRUE, stringsAsFactors = FALSE)

plot(ff$콜레라,ylim=c(0,6000),axes=FALSE,col="violet",type="o",lwd=1, main="1군전염병발병현황_년도별 (단위:건수) 출처: 통계청",xlab'년도')
axis(1,at=1:11,labels=ff$년도별,las=2)
axis(2)
lines(ff$장티푸스,col="blue",type="o",lwd=1)
lines(ff$이질,col="red",type="o",lwd=1)
lines(ff$대장균,col="black",type="o",lwd=1)
lines(ff$A형간염,col="orange",type="o",lwd=1)
abline(h=seq(0,6000,100),v=seq(1,11,1),lty=3,lwd=0.2)
legend(x=1,y=6000,legend=names(ff[2:6]),cex=0.8,fill=c("violet","blue","red","black","orange"),pch=15,lty=1,lwd=2)


#axis : X축(1), Y축(2) 생성
#abline : 엑셀과 같이 축을 생성 h: y축, v=x축


# 그룹형

a<-ff$년도별
b<-ff[,-1] 
c<-t(as.vector(b[,1]))
d<-t(as.vector(b[,2]))
e<-t(as.vector(b[,3]))
f<-t(as.vector(b[,4]))
g<-t(as.vector(b[,5]))
h<-barplot(rbind(c,d,e,f,g),beside=T,main="1군전염병발병현황_년도별 (단위:건수) 출처 : 통계청",xlab='년도',ylim=c(0,6000),col=rainbow(length(b)),names.arg=a)
text(x=h,y=rbind(c,d,e,f,g),labels=rbind(c,d,e,f,g),cex=0.3,pos=3)
legend("topleft",names(b),fill=rainbow(length(b)))

# 다른답안

zz<-dcast(melt(ff),variable~년도별)
as.matrix(zz[-1])

[문제164] 조사된 데이터 값들이 있습니다. 도수분포표를 만드세요.

90 88 78 65 80 94 69 72 83 64 95 68 87 69 82 91 63 70 81 67 

              계급 도수
           90점이상    4
  80점이상~90점미만    6
  70점이상~80점미만    3
  60점이상~70점미만    7

# scan() : 값을 한번에 불러오는 함수 

score<-scan() ctrl + enter
90 88 78 65 80 94 69 72 83 64 95 68 87 69 82 91 63 70 81 67 
ctrl + enter
한번에 값을 불러낸다

a<-c(90, 88, 78, 65, 80, 94, 69, 72, 83, 64, 95, 68, 87, 69, 82, 91, 63, 70, 81, 67)
b<-data.frame(계급=c('90점이상','80점이상~90점미만','70점이상~80점미만','60점이상~70점미만','전체'),도수=0)
for(i in 1:length(a)){ifelse(a[i]>=90,b$도수[1]<-b$도수[1]+1,ifelse(a[i]>=80,b$도수[2]<-b$도수[2]+1,ifelse(a[i]>=70,b$도수[3]<-b$도수[3]+1,b$도수[4]<-b$도수[4]+1)))}
b$도수[5]<-sum(b$도수)
c<-c(prop.table(b$도수[1:4]),sum(prop.table(b$도수[1:4])))
b<-cbind(b,c)
colnames(b)[3]<-c('상대도수')
d<-0
b<-cbind(b,d)
colnames(b)[4]<-c('누적도수')
b$누적도수[1]<-b$도수[1]
for (i in 1:(length(b)-1)){b$누적도수[i+1]<-b$누적도수[i]+b$도수[i+1]
                           if(i==(length(b)-1)){
                             b$누적도수[5]<-NA}}

[문제165] itwill 자동차 수리점 부품 비용 자료 입니다. 분석하세요.


91 78 93 57 75 52 99 80 97 62
71 69 72 89 66 75 79 75 72 76
104 74 62 68 97 105 77 65 80 109
85 97 88 68 83 68 71 69 67 74
62 82 98 101 79 105 79 69 62 73

# 비용값을 plot 

max(a)
min(a)
length(a)
round(50^(1/3))
b<-cut(a,breaks = seq(50,110,15),right=FALSE,labels=c('95이상 110미만','80이상 95미만','65이상 80미만','50이상 65미만'))
b.table<-table(b)
c.prop<-prop.table(b.table)
data<-cbind(b.table,c.prop)
data<-as.data.frame(data)
colnames(data)<-c('도수','상대도수')
plot(data$도수,main='itwill 자동차 수리점 부품 비용 (단위: 만원)',xlab='범위',ylab='개수',ylim=c(0,30),axes=FALSE,lwd=1,type='o',col='red')
axis(1,at=1:4,labels=rownames(data))
axis(2,at=1:30)

# 히스토그램 + plot

hist(a,breaks=seq(50,110,by=15),right=FALSE,col=rainbow(4),labels=TRUE,ylim=c(0,30),main="",axes=FALSE,ylab="",xlab="")
par(new=T)
plot(data$도수,main='itwill 자동차 수리점 부품 비용 (단위: 만원)',xlab='범위',ylab='건수',ylim=c(0,30),axes=FALSE,lwd=2,type='o',col='red')
legend("topright",rownames(data),cex=0.5,fill=rainbow(4),title='단위: 만원')

# 부품을 여러개로 본 경우
aa<-matrix(c(a),ncol=10,byrow=TRUE)
aa<-as.data.frame(aa)
colnames(aa)<-c('A','B','C','D','E','F','G','H','I','J')
rownames(aa)<-c('2001년','2002년','2003년','2004년','2005년')
bb<-as.matrix(aa)
cc<-barplot(bb,beside=T,col=rainbow(length(rownames(aa))),ylim=c(0,120),xlab='부품이름',axes=FALSE,main='itwill 자동차 수리점 부품 비용 (단위: 만원)')
text(x=cc,y=bb,labels=bb,pos=3,cex=0.5)
legend("topleft",rownames(aa),fill=rainbow(length(rownames(aa))),cex=0.3)


[문제166] 학생들의 몸무게 자료를 이용해서 도수분포표,그래프를 생성하세요.

weight <- read.table("c:/data/weight.txt")

# 필드와 필드사이가 (,) 라면 read.csv 아니면 read.table로 한다.

w<-as.vector(unlist(weight))
max(w)
min(w)
length(w)
stem(w)
ww<-cut(w,breaks=seq(50,100,by=10),right=FALSE,labels=c('50이상 60미만','60이상 70미만','70이상 80미만','80이상 90미만','90초과'))
ee<-xtabs(~ww)
data<-data.frame(구간=names(ee),도수=as.vector(ee),상대도수=as.vector(prop.table(ee)))

hist(w,breaks=seq(50,100,by=10),ylim=c(0,25),col=rainbow(5),main="몸무게 (단위: 명)",xlab="",ylab='인원수',labels=T,sub='kg')
par(new=T)
plot(density(w),type='l',xlim=c(50,100),axes=FALSE,main="",ylab="",xlab="",lwd=2)
legend("topleft",as.vector(data$구간),fill=rainbow(5),cex=0.4,title='단위 : kg')

stem(w)

[문제167] 2016년_서울_주요구별_병원현황.csv file을 읽어 들인후 구별로 진료과목별 병원현황을 그룹막대형 그래프로 만드세요.

seo<-read.csv('c:/data/2016년_서울_주요구별_병원현황.csv',header=T,stringsAsFactors=FALSE)
head(seo)
seo1<-colnames(seo)
seo2<-seo[,1]
seo2
seo1
seo1<-seo1[-1]
aa<-seo
colnames(aa)<-NULL
aa<-aa[,-1]
aa<-t(aa)
aa
colnames(aa)<-seo2
rownames(aa)<-seo1
max(aa)
bb<-barplot(aa,beside=T,ylim=c(0,max(aa)+50),col=rainbow(length(rownames(aa))),main="2016년_서울_주요구_병원현황",axes=FALSE)
text(x=bb,y=aa,pos=3,cex=0.3)
legend("topright",rownames(aa),fill=rainbow(length(rownames(aa))),cex=0.5)

[문제168] 강남구 과목별 병원수만 막대형 그래프를 생성하세요.(단 10개 1개로 표현하세요.)

seo3<-seo[,c('표시과목','강남구')]
seo4<-seo3[,c('강남구')]/10
seo4
cc<-barplot(seo3[,c('강남구')],names.arg=seo[,c('표시과목')],col='blue',ylim=c(0,max(seo3[,c('강남구')])+50),axes=FALSE,main='강남구 과목별 병원수')
text(x=cc,y=seo3[,c('강남구')],seo3[,c('강남구')],pos=3)
dd<-barplot(seo4,names.arg=seo[,c('표시과목')],col=rainbow(length(seo[,c('표시과목')])),ylim=c(0,max(seo4)+10),main='강남구 과목별 병원수 (단위: 10개당 1)',las=2)
text(x=dd,y=seo4,seo4,pos=3)
legend("topright",seo[,c('표시과목')],fill=rainbow(length(seo[,c('표시과목')])),cex=0.8)

[문제169] 2016년_서울_주요구별_병원현황.csv file을 읽어 들인후 구별 진료과목에 해당하는 병원수를 막대형 그래프로 만드세요. 
단 막대높이는 10개당 1개로 만드시고 막대그래프 프로그램은 한개를 가지고 모든 구별 막대그래프가 생성되도록 만드세요.

graphics.off()
par(mfrow=c(2,5))
par(mar=c(2,2,1,1))
seo[,c('표시과목')]
name<-colnames(seo)
name<-name[-1]
name
seo1<-seo[,-1]
seo1[,1]
for(i in 1:length(colnames(seo))){
      a<-barplot(seo1[,i]*0.1,names.arg=seo[,c('표시과목')],col=rainbow(length(seo[,c('표시과목')])),ylim=c(0,40),main=paste(name[i],'병원현황',' (단위: 10개당 1)'))
      text(x=a,y=seo1[,i]*0.1,seo1[,i]*0.1,cex=1,pos=3)
      abline(h=seq(0,40,5),lty=3,lwd=0.2)
     
}


[문제 170] 모기업의 영업팀은 'A팀','B팀','C팀','D팀','E팀' 있습니다.
           영업팀별 영업매출액은 90,45,70,67,85 있습니다.
           이 자료를 이용해서 barplot,pie,pie3D 그래프를 생성하세요.

library(jpeg)

jpeg("c:/data/ex170_1.jpg",width=400,height=300,pointsize=12)
a<-c('A팀','B팀','C팀','D팀','E팀')
b<-c(90,45,70,67,85)
c<-barplot(b,col=rainbow(5),ylab=c(0,120),main='영업팀별 영업매출액', names.arg=a,axes=FALSE)
text(c,b,b,pos=3)
dev.off

jpeg("c:/data/ex170_2.jpg",width=400,height=300,pointsize=12)
pie(b,main='영업팀별 영업매출액',labels=paste(a,':','\n',b),col=rainbow(5))
dev.off()


library(plotrix)
jpeg("c:/data/ex170_3.jpg",width=400,height=300,pointsize=12)
pie3D(b,main='영업팀별 영업매출액',labels=paste(a,':',b))
dev.off()

[문제171] 문제169번을 수행하면서 구이름.jpg형식으로 파일이 생성하도록 한후
	  구이름.jpg를 이용해서 애니메이션을 수행하세요.

seo[,c('표시과목')]
name<-colnames(seo)
name<-name[-1]
name
seo1<-seo[,-1]
seo1[,1]
for(i in 1:length(colnames(seo))){
  jpeg(paste("c:/data/",name[i],".jpg",sep=""),width=400,height=300,pointsize=12)
      a<-barplot(seo1[,i]*0.1,names.arg=seo[,c('표시과목')],col=rainbow(length(seo[,c('표시과목')])),ylim=c(0,40),main=paste(name[i],'병원현황',' (단위: 10개당 1)'),cex.names=0.85)
      text(x=a,y=seo1[,i]*0.1,seo1[,i]*0.1,cex=1,pos=3)
      abline(h=seq(0,40,5),lty=3,lwd=0.2)
  dev.off()
}

for (i in 1:10){
  img<-paste("c:/data/",name[i],".jpg",sep="")
  img<-readJPEG(img)
  
  plot.new()
  rect(0,0,1,1,col="white",border="white") 
  rasterImage(img,0,0,1,1)
  ani.pause() 
}

[문제172] R에서 오라클 접속한 후 부서별 인원수에 대한 막대그래프 그리세요.

library(RJDBC)
emp <- dbGetQuery(conn, "select * from employees")
dept <- dbGetQuery(conn, "select * from departments")
jdbcDriver <- JDBC(driverClass="oracle.jdbc.OracleDriver", classPath="C:/data/ojdbc6.jar") # 네트워크 설정, ojdbc6.jar: 오라클과 연동되게 하는 파일  
conn <- dbConnect(jdbcDriver, "jdbc:oracle:thin:@localhost:1521/xe", "hr",  "hr") # localhost-> 연결할 컴퓨터,IP주소/SID (memory이름), 오라클계정, 패스워드
library(dplyr)
library(plyr)
a<-ddply(emp,'DEPARTMENT_ID',summarise,deptid_cn=length(EMPLOYEE_ID))
a[which(is.na(a)),c('DEPARTMENT_ID')]<-c('부서없음')
b<-barplot(a$deptid_cn,ylim=c(0,50),names.arg = a$DEPARTMENT_ID,col=rainbow(length(a$DEPARTMENT_ID)),main='부서별 인원수',xlab='부서번호',axes=FALSE)
text(x=b,y=a$deptid_cn,paste(a$deptid_cn,'명',sep=""),pos=3)
legend("topright",a$DEPARTMENT_ID,fill=rainbow(length(a$DEPARTMENT_ID)),cex=0.5,title='부서번호',title.col='red')

# 내림차순 정리 

library(doBy)
d<-orderBy(~-deptid_cn,aa)
d[which(is.na(d)),c('DEPARTMENT_ID')]<-c('부서없음')
e<-barplot(d$deptid_cn,ylim=c(0,50),names.arg = d$DEPARTMENT_ID,col=rainbow(length(d$DEPARTMENT_ID)),main='부서별 인원수',xlab='부서번호',axes=FALSE)
text(x=e,y=d$deptid_cn,paste(d$deptid_cn,'명',sep=""),pos=3)
legend("topright",d$DEPARTMENT_ID,fill=rainbow(length(d$DEPARTMENT_ID)),cex=0.5,title='부서번호',title.col='red')

f <- dbGetQuery(conn, "select nvl(department_id,'소속부서(x)'), count(*) from employees group by nvl(department_id,'소속부서(x)')")

[문제173] 아래와 같은 결과를 출력하도록 SQL문을 작성하세요.


Job                     Dept 10    Dept 20    Dept 30    Dept 40    Dept 50    Dept 60    Dept 70    Dept 80    Dept 90   Dept 100
-------------------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ----------
AC_MGR
AC_ACCOUNT
IT_PROG                                                                          28800
ST_MAN                                                                36400
AD_ASST                       0
PU_MAN                                          11000
SH_CLERK                                                              64300
AD_VP                                                                                                     35700
FI_ACCOUNT                                                                                                           39600
MK_MAN                               13000
PR_REP                                                                                      10000
FI_MGR                                                                                                               12008
PU_CLERK                                        13900
SA_MAN                                                                                                 61000
MK_REP                                6000
AD_PRES                                                                                                   26400
SA_REP                                                                                                243500
HR_REP                                                      6500
ST_CLERK                                                              55700


select job,decode(dept_id,10,sum_sal)  as Dept_10,
           decode(dept_id,20,sum_sal)  as Dept_20,
           decode(dept_id,30,sum_sal)  as Dept_30,
           decode(dept_id,40,sum_sal)  as Dept_40,
           decode(dept_id,50,sum_sal)  as Dept_50,
           decode(dept_id,60,sum_sal)  as Dept_60,
           decode(dept_id,70,sum_sal)  as Dept_70,
           decode(dept_id,80,sum_sal)  as Dept_80,
           decode(dept_id,90,sum_sal)  as Dept_90,
           decode(dept_id,100,sum_sal) as Dept_100
           from (select job_id job,department_id dept_id, sum(salary) sum_sal 
                 from employees 
                 group by department_id,job_id



[문제174] 문제 173번에서 만든 SQL문을 R에서 오라클로 접속하셔서 수행하세요.

library(RJDBC)
emp <- dbGetQuery(conn, "select * from employees")
jdbcDriver <- JDBC(driverClass="oracle.jdbc.OracleDriver", classPath="C:/data/ojdbc6.jar") 
conn <- dbConnect(jdbcDriver, "jdbc:oracle:thin:@localhost:1521/xe", "hr",  "hr") 

dbGetQuery(conn,"select job,decode(dept_id,10,sum_sal)  as Dept_10,
                            decode(dept_id,20,sum_sal)  as Dept_20,
                            decode(dept_id,30,sum_sal)  as Dept_30,
                            decode(dept_id,40,sum_sal)  as Dept_40,
                            decode(dept_id,50,sum_sal)  as Dept_50,
                            decode(dept_id,60,sum_sal)  as Dept_60,
                            decode(dept_id,70,sum_sal)  as Dept_70,
                            decode(dept_id,80,sum_sal)  as Dept_80,
                            decode(dept_id,90,sum_sal)  as Dept_90,
                            decode(dept_id,100,sum_sal) as Dept_100
                            from (select job_id job,department_id dept_id, sum(salary) sum_sal 
                                  from employees 
                                  group by department_id,job_id)")


[문제175] R에서 오라클에 있는 EMPLOYEE 테이블을 읽어 들인 후 R함수를 이용하셔서 문제 173번과 동일한 결과를 출력하세요

emp <- dbReadTable(conn, "EMPLOYEES")
tapply(emp$SALARY,list(emp$JOB_ID,emp$DEPARTMENT_ID),sum, default=0)

[문제176] 부서 인원수를 ggplot를 이용해서 막대그래프를 출력하세요.

a<-ddply(emp,'DEPARTMENT_ID',summarise,dept_cn=NROW(EMPLOYEE_ID))
a$DEPARTMENT_ID
a$dept_cn
a$DEPARTMENT_ID[is.na(a$DEPARTMENT_ID)]<-0
ggplot(a,aes(x=DEPARTMENT_ID,y=dept_cn))+
      geom_bar(stat="identity",fill="blue",colour="black")+
      theme(axis.text.x=element_text(angle=45,hjust=1,vjust=1,colour = "black",size=10))+
      ggtitle("부서별 직원 수")+
      labs(x="부서번호",y="인원 수 (단위: 명)")+  
      geom_text(aes(label=dept_cn),position=position_stack(vjust = 0.5),color="red")

[문제177] 년도별 입사한 수를 ggplot를 이용해서 막대그래프를 출력하세요.

b<-dbGetQuery(conn,"select to_char(hire_date,'yyyy') as year,count(*) as cn from employees group by to_char(hire_date,'yyyy')")
b$YEAR<-as.numeric(b$YEAR)
b<-orderBy(~YEAR,b)
b
ggplot(b,aes(x=YEAR,y=CN))+
      geom_bar(stat="identity",fill="green",colour="red")+
      theme(axis.text.x=element_text(angle=45,hjust=1,vjust=1,colour = "black",size=10))+
      ggtitle("연도별 입사 한 수")+
      labs(x="연도",y="인원 수 (단위 : 명)")+
      geom_text(aes(label=CN),position=position_stack(vjust = 0.5),color="red")

[문제178] 학생들의 과목 점수를 각각으로 막대그래프를 그리세요.

ggplot(df, aes(x=name, y=grade))+
  geom_bar(stat="identity",fill="red")+
  theme(axis.text.x = element_blank())+
  facet_wrap(~ name+subject)

ggplot(df, aes(x=subject, y=grade, group=name))+
  geom_col(aes(fill=subject))+
  theme(axis.text.x = element_blank())+
  facet_wrap(~ name)

[문제179] 'Mata','Young' 학생의 과목점수를 선 과점 그래프로 생성하세요.

a<-df[df$name==c('Mata')|df$name==c('Young'),]
b<-df[df$name %in% c('Mata','Young'),]

ggplot(a,aes(x=subject,y=grade,color=name,group=name))+
  geom_line()+
  geom_point()

[문제180] seoul.txt 파일을 단어별 빈도수를 확인 하시고 wordcloud를 그리세요.

seo<-readLines('c:/data/seoul.txt') # 파일불러오기
sim<-unlist(SimplePos09(seo)) # list형에서 비교하기 힘드므로 unlist해서 푼다.
ple<-grep('/N',sim,value=TRUE) # /N 이 단어가 있는 것이므로 분류
zz<-c() # 빈 벡터 생성
for (i in 1:length(ple)){ 
    zz[i]<-print(strsplit(ple,split='/')[[i]][1])
} # 벡터에 값들 넣는다.
zz
zz<-zz[-(grep('[[:digit:]]',zz))] # 숫자를 제외
cn<-table(zz) # 빈도수 체크
pal<-brewer.pal(8,"Dark2") # 색깔 넣기
cn2<-cn[cn>=2]
wordcloud(names(cn),freq=cn,scale=c(2,0.1),min.freq=2,random.order = F,rot.per=.1,colors=pal)
wordcloud2(cn2,shape="star")

#다른방법

sim1<-unlist(extractNoun(seo))
ple1<-sim1[-(grep('[[:digit:]]',sim1))]
cn1<-table(ple1)
cn1
cnn<-cn1[cn1>=2]
wordcloud(names(cn1),freq=cn,scale=c(2,0.1),min.freq=2,random.order = F,rot.per=.1,colors=pal)
wordcloud2(cnn,shape="star")

[문제181] jeju.txt를 분석하세요

#텍스트 불러오기
jeju<-readLines("c:/data/jejuisland.txt")
jeju<-unique(jeju)
jeju[grep('중문',jeju)]<-'중문'
jeju[grep('우도',jeju)]<- '우도'
jeju<-unique(jeju)
jeju<-c(jeju,'이중섭거리') 

# 관광지에서 수정한 후 새로 추가
write(jeju,'c:/data/jeju1.txt')
data2<-data1 # 데이터 손실방지

# 데이터 정제하기 (정제값 및 str_replace_all 사용)
for (i in 1:length(jeju)){
  A[i]<-jeju[i]
  B[i]<-paste("[[:alpha:]]{0,}",A[i],"[[:alpha:]]{0,}",sep="")
  data2<-str_replace_all(data2,B[i],A[i])
}
unlist(str_extract_all(data2,"[[:alpha:]]{0,}우도[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}우도[[:alpha:]]{0,}","우도")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}성산[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}성산[[:alpha:]]{0,}","성산일출봉")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}일출봉[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}일출봉[[:alpha:]]{0,}","성산일출봉")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}천지연[' ']{0,}[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}천지연[' ']{0,}[[:alpha:]]{0,}","천지연폭포")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}천제연[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}천제연[[:alpha:]]{0,}","천제연폭포")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}테디[' ']{0,}[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}테디[' ']{0,}[[:alpha:]]{0,}","테디베어뮤지엄")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}한라[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}한라[[:alpha:]]{0,}","한라산")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}오설[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}오설[[:alpha:]]{0,}","오설록티뮤지엄")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}아쿠아[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}아쿠아[[:alpha:]]{0,}","아쿠아플라넷")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}동백[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}동백[[:alpha:]]{0,}","카멜리아힐")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}쇠소[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}쇠소[[:alpha:]]{0,}","쇠소깍")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}이중[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}이중[[:alpha:]]{0,}","이중섭거리")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}용머리[' ']{0,}[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}용머리[' ']{0,}[[:alpha:]]{0,}","용머리해안")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}도깨비[' ']{0,}[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}도깨비[' ']{0,}[[:alpha:]]{0,}","신비의도로")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}천백도[' ']{0,}[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}천백도[' ']{0,}[[:alpha:]]{0,}","1100도로")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}천백십[' ']{0,}[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}천백십[' ']{0,}[[:alpha:]]{0,}","1112도로")
unlist(str_extract_all(data2,"[[:alpha:]]{0,}애월[' ']{0,}[[:alpha:]]{0,}"))
data2<-str_replace_all(data2,"[[:alpha:]]{0,}애월[' ']{0,}[[:alpha:]]{0,}","애월해안도로")

# 단어 나누기 위해 사전에 추가
buildDictionary(ext_dic="sejong",
                user_dic=data.frame(readLines('c:/data/jeju1.txt'),"ncn"),
                replace_usr_dic=T)
# 단어 나누기
data3<-extractNoun(data2)
length(data3)

# 중복된 값 제거
for (i in 1:length(data3)){
  data3[[i]]<-unique(data3[[i]])
}
data4<-unlist(data3)
data5<-data4[data4 %in% jeju]

# 가장 많이 추천한 10곳 생성
data<-head(sort(table(data5),decreasing = T),10)
data

## 지도로 표현
library(ggmap)
library(ggplot2)
names<-dimnames(data)
da<-data.frame(lon=c(),lat=c())
names<-as.vector(unlist(names))
da<-geocode(enc2utf8(names[1]))
names<-c(names,"제주국제공항") # 시작점 추가

# 좌표값 생성
for (i in 2:length(names)){
  da[i,]<-geocode(enc2utf8(names[i]))
}
geo_dat<-da

# 지도 생성
cen<-c(mean(geo_dat$lon),mean(geo_dat$lat))
map<-get_googlemap(center=cen,maptype="roadmap",zoom=10,markers=geo_dat) 
gmap<-ggmap(map,extent="device")
gmap+geom_text(data=geo_dat,aes(x=lon,y=lat),size=3,label=names)

[문제182] noise.txt 데이터를 시각화 하세요.

a<-scan()
noise<-a

max(noise) # 77.1
min(noise) # 44

length(noise) # 50

hi<-cut(noise,breaks = seq(40,80,by=8),right=FALSE,
        labels=c('40이상 48미만','48이상 56미만','56이상 64미만','64이상 72미만','72이상 80미만')) # 구간 정하고, 입력

hi.table<-table(hi) # 테이블 생성
hi.table
hi.prop<-prop.table(hi.table) # 비율 확인
hi.prop

hist(noise,breaks=seq(40,80,by=8),right=FALSE,col=rainbow(5),labels=TRUE,
     ylim=c(0,35),main="",axes=FALSE,ylab="",xlab="") # 히스토그램 생성 

legend("topright",c('40이상 48미만','48이상 56미만','56이상 64미만','64이상 72미만','72이상 80미만'),
       cex=0.5,fill=rainbow(5),title='단위: 8')

[문제183] noise.txt 데이터에서 25%의 기준 데이터 75%의 기준 데이터를 찾으세요.

qu_no<-quantile(noise)

max(noise[noise<=qu_no[names(qu_no)=='25%']])
max(noise[noise<=qu_no[names(qu_no)=='75%']])

quantile(noise, probs=c(0.25,0.75))

[문제184] food.csv 데이터를 기준으로 토마토의 sweetness은 6,  crunchiness은 4 입니다. 분류를 하세요.

# 비교하는 값들 끼리만 비교를 하고 knn 을 구하면 된다.

food<-read.csv('c:/data/food.csv',stringsAsFactors = FALSE, header=T)
test<-data.frame(ingredient='tomato',sweetness=6,crunchiness=4)
test
train<-food[,2:3]
train
group<-food[,4]
group
library(class)
food
knn(train,test[,2:3],group,k=3,prob=TRUE)

[문제185]  나이, 월수입, 상품구매여부를 갖는 데이터가 있다.
         이 데이터를 이용해서 나이가 44 이고 월급이 400 만원인 사람이
         상품을 구매할지 비구매할지를 knn 분류 알고리즘으로 분석하세요.

library(class)

buy<-read.csv('c:/data/buy.csv',header=T,stringsAsFactors = FALSE)

z<-c()
y<-c()
for (i in 1:NROW(buy)){
  z[i]<-(buy$나이[i]-mean(buy$나이))/sd(buy$나이)
  y[i]<-(buy$월수입[i]-mean(buy$월수입))/sd(buy$월수입)
}

train<-cbind(z,y)

test<-c((44-mean(buy$나이))/sd(buy$나이),(400-mean(buy$월수입))/sd(buy$월수입))
group<-buy[,3]

knn(train,test,group,k=1,prob=T)

[문제186] zoo.csv 데이터 집합은 동물의 특징과 부류 정보가 있습니다. 
	  특정 데이터 동물 정보가 어느 부류에 속하는 지를 knn 알고리즘을 이용해서 분석하세요.

[변수 정보]

   1. animal name:      Unique for each instance
   2. hair		Boolean
   3. feathers		Boolean
   4. eggs		Boolean
   5. milk		Boolean
   6. airborne		Boolean
   7. aquatic		Boolean
   8. predator		Boolean
   9. toothed		Boolean
  10. backbone		Boolean
  11. breathes		Boolean
  12. venomous		Boolean
  13. fins		Boolean
  14. legs		Numeric (set of values: {0,2,4,5,6,8})
  15. tail		Boolean
  16. domestic		Boolean
  17. catsize		Boolean
  18. type		Numeric (integer values in range [1,7])

[18. type]
1 : 포유류
2 : 조류
3 : 파충류
4 : 어류
5 : 양서류 
6 : 곤충
7 : 갑각류 

zoo<-read.csv('c:/data/zoo.csv',header=F,stringsAsFactors = FALSE)
name<-c('포유류','조류','파충류','어류','양서류','곤충','갑각류')
for (i in 1:length(name)){
  zoo[which(zoo[,18]==i),18]<-name[i]
}

train<-zoo[,2:17]
train<-train[-101,]
test<-zoo[101,-c(1,18)]
group<-zoo[-101,18]
test

knn(train,test,group,k=1)

[문제187] 유방암 데이터 입니다. kNN알고리즘을 이용해서 훈련데이터셋,테스트데이터셋을 이용해서 분류가 잘되는지 확인하세요.


- 위스콘신대학의 연구원들의 자료
- 유방 종양의 미세침 흡인물 디지털 이미지에서 측정한 값 이며 이 값은 디지털 이미지에 나타난 세포 핵의 특징이다.
- 암조직 검사에 대한 관측값은 569개, 변수(속성) 32
- 식별숫자, 암진단 여부(악성(Malignant),양성(Benign)), 30개 수치 측정치
- 세포핵의 모양과 크기관련된 10개 특성
	* radius(반지름)
	* texture(질감)
	* perimeter(둘레)
	* area(넓이)
	* smoothness(매끄러움)
	* compactness(조밀성)
	* concavity(오목함)
	* concave points(오목점)
	* symmetry(대칭성)
	* fractal dimension(프랙탈 차원)

wis<-read.csv('c:/data/wisc_bc_data.csv',header=T,stringsAsFactors = FALSE)
wis
colnames(wis)
# dummy coding : 의미있는 숫자로 변환을 해줘야 하는 코딩

# 검증

group<-wis[,2]
train<-wis[,3:length(wis)]
summary(train)
scale(train)

normalize <- function(x) {
  return ((x - mean(x)) / sd(x))
}

train_n <- as.data.frame(lapply(train, normalize))
head(train_n)
summary(train_n)

wis1<-wis
wis1[,3:length(wis1)]<-train_n
head(wis1)

set.seed(1234)

# 트레이닝(60%), 테스트(40%) - 표준화로 비교

nrow(train_n)

train_sample<-sample(2,nrow(wis1),replace=TRUE,prob=c(0.6,0.4))
train_sample

wis_train<-wis1[train_sample==1,3:length(wis1)]
wis_train_label<-wis1[train_sample==1,2]

wis_test<-wis1[train_sample==2,3:length(wis)]
wis_test_label<-wis1[train_sample==2,2]

library(class)

wis_model <- knn(wis_train,wis_test,wis_train_label, k=19)
wis_model

library(gmodels)

CrossTable(x = wis_test_label, y = wis_model, prop.chisq=FALSE)

# test 해보기- 표준화 안한 것으로 비교

a<-train[130,]
knn(train,a,group,k=19)

# [0,1] max, mean 으로 비교 

normalize1 <- function(x) {
  return ((x - min(x)) / (max(x)-min(x)))
}

train_n1 <- as.data.frame(lapply(train, normalize1))
train_n1

wis2<-wis
wis2[,3:length(wis1)]<-train_n1

set.seed(1234)

# 트레이닝(60%), 테스트(40%) - max,min 표준화로 비교

train_sample<-sample(2,nrow(wis1),replace=TRUE,prob=c(0.6,0.4))
train_sample

wis_train1<-wis2[train_sample==1,3:length(wis1)]
wis_train_label1<-wis2[train_sample==1,2]

wis_test1<-wis2[train_sample==2,3:length(wis)]
wis_test_label1<-wis2[train_sample==2,2]

library(class)

wis_model1 <- knn(wis_train1,wis_test1,wis_train_label1, k=19)
wis_model

library(gmodels)

CrossTable(x = wis_test_label1, y = wis_model1, prop.chisq=FALSE)
knn(wis_train1,wis2[130,3:length(wis2)],wis_train_label1,k=19)

[문제188] 새환자의 초음파 결과를 보고 종양이 양성인지 악성인지를 분석해 주세요

p<-read.csv('c:/data/patient.csv',header=T,stringsAsFactors = FALSE)

t<-p[,3:length(p)]

knn(train,t,group,k=19)

NROW(z_train)

z_train<-rbind(train,t)
n_train<-rbind(train,t)



z_train<-as.data.frame(lapply(z_train,normalize)) # Z
n_train<-as.data.frame(lapply(n_train,normalize1)) # [0,1]

z_test<-z_train[NROW(z_train),] # z
n_test<-n_train[NROW(n_train),] # [0,1]

NROW(group)
knn(z_train[1:(NROW(z_train)-1),],z_test,group,k=19,prob=T)
knn(n_train[1:(NROW(n_train)-1),],n_test,group,k=19,prob=T)

[문제189] JOB_ID 별로 월급의 차이가 존재하는지 crosstable로 분석하려고 합니다.
월급 10000을 기준으로 JOB_ID 별로 각각 10000 이상인 사원과 이하인 사원들의 인원수가 출력하세요.

emp<-read.csv('c:/data/emp.csv',header=T,stringsAsFactors = FALSE)

emp['sal_yn']<-ifelse(emp$SALARY>=10000,'10000원이상','10000원미만')
emp$JOB_ID
emp$sal_yn
CrossTable(x=emp$JOB_ID,y=emp$sal_yn, prop.chisq=FALSE)

[문제 190] 수강생이 다른 세반의 평균은?

반  수강생 반평균
1    40     70
2    35     75
3    25     80

((40*70)+(35*75)+(25*80))/100

data<-data.frame('class'=c(1,2,3),'student'=c(40,35,25),'avg'=c(70,75,80))

sum(data$student*data$avg)/sum(data$student)

[문제 191] 홍하든, 박커리 두 학생이 확률통계(3학점), 컴퓨터 시스템(2학점)을 수강한 결과 홍하든은 확률통계에서 A학점,
           컴퓨터 시스템에서 B학점을 받았고, 박커리는 확률통계에서 B학점, 컴퓨터시스템에서 A학점을 받았다.
           A학점의 평점은 4, B학점의 평점은 3 일때 학점수를 가중치로 하여 두학생의 평균 평점을 구하세요.
           
(3*4+2*3)/5
(3*3+2*4)/5

[문제 192] 전년도 대비 증가율을 구하세요.

년도  수익  증가율
2013  635   
2014  998
2015  1265
2016  1701
2017  2363

((998-635)/635) * 100
((1265-998)/998) * 100
((1701-1265)/1265) * 100
((2363-1701)/1701) * 100

[문제 193] 5년동안 연평균 변화율은?

(2365/635)^(1/4)-1

[문제 194] 서울과 부산(400km)를 왕복하는데 서울에서 부산으로 가는데 시속 150km/h 가고 오는데 시속 100km/h 로 왔다면
왕복하는데 걸린 평균 시속은?

400/((400/150 + 400/100) /2)

[문제195] 가구당 자녀수

p<-c(2,3,0,2,1,0,3,1,4)

mean(p)±sd(p)

[문제196] 병원진료시간 어느병원으로 가면 좋을까요?

A 병원 10 15 17 17 23 20  
B 병원 17 32 5  19 20 9

a<-c(10,15,17,17,23,20)
b<-c(17,32,5,19,20,9)

mean(a)
mean(b)
sd(a)
sd(b)

# A로 가는것이 좋다 

[문제197] 관측데이터값들을 확인 한 후 NA값이 있을 경우 산술평균으로 수정해주세요

1,3,4,NA,10,NA,8,2

a<-c(1,3,4,NA,10,NA,8,2)

a[is.na(a)]<-mean(na.omit(a))

a


[문제198] 관측데이터들을 확인 한 후 NA 값이 있을 경우 내가 만든 함수를 통해서 산술평균의 값으로 수정해 주세요.

1,3,4,NA,10,NA,8,2

f<-function(x){
  ifelse(is.na(x)==T,x[which(is.na(x))]<-mean(x,na.rm=T),x)  
}
a<-c(1,3,4,NA,10,NA,8,2)
a<-f(a)


[문제199] sample 함수를 통해서 1부터 100까지의 숫자들 중에 60개만 랜덤하게 추출해서 matrix를 생성하세요.
          행은 6행으로 만드세요.
          생성한 행렬의 값 중에 3행 2열에 NA 값, 5행4열에 NA값으로 수정하세요.
          198에서 만든 함수를 이용해서 NA값은 열을 기준으로 하는 평균값으로 수정하세요/
          
set.seed(1234)
m<-matrix(sample(1:100,60),nrow=6)
m[3,2]<-NA
m[5,4]<-NA

for (i in 1:ncol(m)){
  m[,i]<-f(m[,i])
}

[문제200]A반 B 반의 수학점수를 비교하세요.

A반 35,55,60,70,100
B반 55,60,65,65,75

A<-c(35,55,60,70,100)
B<-c(55,60,65,65,75)

mean(A)
sd(A)
mean(B)
sd(B)

# 두반의 평균은 같지만 표준편차로 봤을 때 B반의 성적의 분포가 고르다는 것을 볼 수 있기 때문에, 대체적으로 B반학생이 A반 학생
# 보다 성적을 잘 받는다.

[문제201] 성적.csv 파일에 과목별 평균값, 분산값, 표준편차값을 행으로 추가하시오.

test<-read.csv('c:/data/성적.csv',header=T,stringsAsFactors=FALSE)

test[(NROW(test)+1),]<-data.frame('평균',mean(test$sql),mean(test$r),stringsAsFactors=FALSE)
test[(NROW(test)+1),]<-data.frame('분산',var(test$sql),var(test$r),stringsAsFactors=FALSE)
test[(NROW(test)+1),]<-data.frame('표준편차',sd(test$sql),sd(test$r),stringsAsFactors=FALSE)

[문제202] carrick의 sql=90점과 pogba의 r=90 둘중 어느 사람이 더 잘한 것인가?

# R과 SQL의 각각 평균은 72이다. 그러나 표준편차 값을 보면 SQL이 R보다 큰 값인 것을 볼 수 있는데 이말은 즉,
# R의 성적은 SQL에 비해 값이 평균에 가깝게 나왔다 (고르게 나왔다)를 의미한다. 
# 그러므로 대부분 R성적을 72 이상에 가까운 점수를 받았을 것이기에 표준편차가 높은 
# SQL 90점을 받은 carrick이 더 잘했다고 할 수 있다.


# 표준화 : 비교해야할 데이터의 기준이 서로 다르므로 같은 기준을 만들어서 비교

normalize<-function(x){
  return((x-mean(x))/sd(x))
}

normalize1<-function(x){
  return((x-min(x))/(max(x)-min(x)))
}

test<-read.csv('c:/data/성적.csv',header=T,stringsAsFactors=FALSE)
test<-cbind(test,normalize(test$sql[1:9]))
test<-cbind(test,normalize(test$r[1:9]))

test[1,4]*10 + 50 # carrick
test[2,5]*10 + 50 # pogba

# T 점수로 했을 땐 포그바가 더 높으므로 포그바가 더 잘봤다고 할수 있다.

[문제203] 지난달을 기준으로 a 사원은 영업 매출이 월 평균 1000만원, 표준편차가 200만원인  대리점을 담당하고있고,
b 사원은 영업 매출이 월 평균 100만원, 표준편차가 10만원인 대리점을 담당하고 있다.
이번달 a 사원이 담당하는 대리점의 매출이 1200만원으로 늘었고, b 사원이 담당하는 대리점은 120만원 늘었다.
평균 매출 대비 20% 상승했다. 누가 잘한거죠?

1000 200 800 1200
100  10   90 110

1200     
120

# b 사원이 잘했다.

a 사원 표준화 : (1200-1000)/200
b 사원 표준화 :(120-100)/10

a사원 T점수 : 1*10+50
b사원 T점수 : 2*10+50

[문제204] 세곳의 채소농원으로부터 10일 동안 측정한 pphm 단위의 오존 농도를 보고 받았다. 오존 농도를 분석하세요.

garden<-read.csv('c:/data/gardens.csv',header=T,stringsAsFactors = FALSE)
garden
A<-normalize(garden$gardenA)*10+50
B<-normalize(garden$gardenB)*10+50
C<-normalize(garden$gardenC)*10+50
D<-as.data.frame(cbind(A,B,C))
D
E<-c()

for (i in 1:NROW(D)){
  E[i]<-which(min(D[i,])==D[i,])
}

table(E)

plot(D$A,type="o",ylim=c(0,80),col="red",xlab='날짜',ylab='오존농도',main='각각 채소농원 A,B,C 의 일별 오존농도')
par(new=T)
plot(D$B,type="o",ylim=c(0,80),col="blue",xlab='',ylab='')
par(new=T)
plot(D$C,type="o",ylim=c(0,80),col="green",xlab='',ylab='')

[문제205] R의 점수입니다. 아래와 같은 성적 분류표를 이용해서 학생들의 학점에  과락, 과락아님 여부 현황 파악을 막대그래프로 표현하세요.


범주   분류 기준     						   과락여부
---   --------------------------------------------------------    -----------   
A     점수 > 평균 + 1.5 * 표준편차		  		    과락아님
B     평균 + 0.5 * 표준편차 < 점수 <= 평균 + 1.5 * 표준편차	    과락아님
C     평균 - 0.5 * 표준편차 < 점수 <= 평균 + 0.5 * 표준편차	    과락아님
D     평균 - 1.5 * 표준편차 < 점수 <= 평균 - 0.5 * 표준편차	    과락
F     점수 <= 평균 - 1.5 * 표준편차			            과락

R<-read.csv('c:/data/r점수.csv',header=F,stringsAsFactors = FALSE)
names(R)<-'score'
t1<-mean(R$score)+1.5*sd(R$score)
t2<-mean(R$score)+0.5*sd(R$score)
t3<-mean(R$score)-0.5*sd(R$score)
t4<-mean(R$score)-1.5*sd(R$score)

R['범주']<-ifelse(R$score>t1,'A',ifelse(t2<R$score&R$score<=t1,'B',ifelse(t3<R$score&R$score<=t2,'C',ifelse(t4<R$score&R$score<=t3,'D','F'))))
R['과락여부']<-ifelse(R$범주 %in% c('A','B','C'),'과락아님','과락')

library(plyr)

total<-tapply(R$score,R$범주,NROW)
total1<-(table(R$범주))
save<-melt(total1)
colnames(save)<-c('범주','명수')
A<-ifelse(names(total) %in% c('A','B','C'),'red','blue')

save$명수

aa<-barplot(total,ylim=c(0,20),col=A,main='R 점수 성적 분류표',xlab='등급',ylab='명')
text(x=aa,y=save$명수,paste(save$명수,'명',sep=""),pos=3)
legend("topright",c('과락아님','과락'),fill=c('red','blue'),cex=0.8)
  
save

ggplot(save,aes(x=범주,y=명수))+
  geom_bar(stat="identity",fill=A)+
  expand_limits(x=0,y=30)+
  geom_text(aes(label=paste(명수,'명',sep="")),position=position_stack(vjust = 1.3),color="black")

[문제206] survey_new.csv 데이터를 아래와 같이 생성하세요.

         만족  보통 불만족 행의합 한계확률
남        2.0  1.0    1.0      4      0.4
여        0.0  4.0    2.0      6      0.6
열의합    2.0  5.0    3.0     10      1.0
한계확률  0.2  0.5    0.3      1      0.1

new<-read.csv('c:/data/survey_new.csv',header=F,stringsAsFactors = FALSE)

new_t<-table(new)
new_t<-rbind(new_t,colSums(new_t))
new_t<-cbind(new_t,rowSums(new_t))
new_t<-rbind(new_t,new_t[3,]/10)
new_t<-cbind(new_t,new_t[,4]/10)
colnames(new_t)<-c('만족','보통','불만족','행의합','한계확률')
rownames(new_t)<-c('남','여','열의합','한계확률')
new_t<-(as.data.frame(new_t))
new_t

[문제207] 3명 중 대표 2명을 선출하여 반장, 부반장으로 임명할 수 있는 경우의 수 ? 6

[문제208] 3명 중 공동대표 2명을 선출하는 경우의 수 ? 3

[문제 207] 주사위 1개를 던졌을 때 A를 4이하의 눈이 나오는 사건,
	   B를 짝수의 눈이 나오는 사건이라고 할 때 
	   사건A가 일어날 확률? 2/3
     사건B가 일어날 확률? 1/2


[문제 208] 주사위 1개를 던졌을 때 A를 4이하의 눈이 나오는 사건,
	   B를 짝수의 눈이 나오는 사건이라고 할 때 사건A와 사건B가 동시에 일어날 확률은? 1/3



[문제 209] 주사위 1개를 던졌을 때 A를 4 이하의 눈이 나오는 사건, B를 짝수의 눈이 나오는 사건이라고 할때, 사건 A가 일어났을 때 B는 짝수의 눈이 나오는 사건의 확률은? 1/2

                                 


[문제 210]  남성이라는 전제 조건하에 안경을 쓴 확률은?  5/11

	안경(O)		안경(X)
--------------------------------
남	  5 		  6
여	  6	   	  4

[문제211] 20대 남성이면서 직업은 IT이고 결혼하지 않고 이성친구가 있는 사람의 영화장르는?

A<-c('20대','남','IT','NO','YES')
B<-movie[1:5]
B[NROW(B)+1,]<-A
predict(model,B[NROW(B)])

[문제212] spam.csv 나이브베이즈를 이용해서 분류를 해보세요.

spam<-read.csv('c:/data/spam.csv',header=T)
spam
spam[is.na(spam)]<-0
total<-naiveBayes(spam[2:length(spam)-1],spam$메일종류,laplace=0)
total
result<-predict(total,spam[2:length(spam)-1])
spam['result']<-result
spam
library(class)
library(gmodels)

CrossTable(x = spam$메일종류, y = result, prop.chisq=FALSE)
CrossTable(x = result, y = spam$메일종류, prop.chisq=FALSE)


[문제213] 일반버섯(식용버섯(edible)) 과 독버섯 분류(먹을수없는버섯(poisonous)) 분류 

이 주소에 가셔서 mushroom 데이터 셋의 정보를 분석한 후 변수들에 어떤 의미가 들어 있는지를 확인 하세요.

https://archive.ics.uci.edu/ml/machine-learning-databases/mushroom/agaricus-lepiota.names

# NA 를 넣은경우

mush<-read.csv("c:/data/mushroom.csv",header=F)

mis<-mush[,12]
mis<-as.vector(mis)
mis1<-factor(mis,c('b','c','e','r'))
mush[,12]<-mis1
train<-naiveBayes(mush[,2:length(mush)],mush$V1,laplace=1)
result<-predict(train,mush[,2:length(mush)])

data.frame(mush$V1,result)

tail(mush)

length(which(mush$V1!=result))
NROW(mush)

334/8124 

# NA를 제거한경우 경우

mush3<-read.csv("c:/data/mushroom.csv",header=F)
mush3<-mush3[-grep('[[:punct:]]',mush3[,12]),]
tail(mush3)
mis3<-mush3[,12]
mis3<-factor(mis3,c('b','c','e','r'))
mush3[,12]<-mis3
train3<-naiveBayes(mush3[,2:length(mush3)],mush3$V1,laplace=1)
result3<-predict(train3,mush3[,2:length(mush3)])
length(which(mush3$V1!=result3))
NROW(mush3)

130/5644

# 뿌리 값에 값을 넣고 비교하려 할 때

mush1<-read.csv("c:/data/mushroom.csv",header=F)

mush1<-mush1[-grep('[[:punct:]]',mush1[,12]),]

mis2<-mush1[,12]
mis2<-factor(mis2,c('b','c','e','r'))
mush1[,12]<-mis2
mush1<-cbind(mush1$V12,mush1)
mush1<-mush1[,-13]

train1<-naiveBayes(mush1[,2:length(mush1)],mush1$`mush1$V12`,laplace=0)
result1<-predict(train1,mush1[,2:length(mush1)])

length(which(result1!=mush1$`mush1$V12`))
NROW(mush1)
12/5644 # 거희 오차가 없다.


mush2<-read.csv("c:/data/mushroom.csv",header=F)
mis3<-mush2[,12]
mis3<-factor(mis3,c('b','c','e','r'))
mush2[,12]<-mis3
A<-mush2$V12
mush2<-mush2[,-12]

train3<-naiveBayes(mush2,A,laplace=0)
result3<-predict(train3,mush2)
mush2<-cbind(mush2,result3)

train4<-naiveBayes(mush2[,2:length(mush2)],mush2$V1,laplace=1)
result4<-predict(train4,mush2)

length(which(mush2$V1!=result4))
NROW(mush2)

355/8124 
